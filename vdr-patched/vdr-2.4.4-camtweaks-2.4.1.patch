diff -Nurp vdr-2.4.4.orig/Makefile vdr-2.4.4/Makefile
--- vdr-2.4.4.orig/Makefile	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/Makefile	2020-07-16 20:10:17.600037433 +0200
@@ -90,7 +90,7 @@ SILIB    = $(LSIDIR)/libsi.a
 OBJS = args.o audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbci.o\
        dvbplayer.o dvbspu.o dvbsubtitle.o eit.o eitscan.o epg.o filter.o font.o i18n.o interface.o keys.o\
        lirc.o menu.o menuitems.o mtd.o nit.o osdbase.o osd.o pat.o player.o plugin.o positioner.o\
-       receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sdt.o sections.o shutdown.o\
+       receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o scapmt.o sdt.o sections.o shutdown.o\
        skinclassic.o skinlcars.o skins.o skinsttng.o sourceparams.o sources.o spu.o status.o svdrp.o themes.o thread.o\
        timers.o tools.o transfer.o vdr.o videodir.o
 
diff -Nurp vdr-2.4.4.orig/ci.c vdr-2.4.4/ci.c
--- vdr-2.4.4.orig/ci.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/ci.c	2020-07-16 20:59:06.930115072 +0200
@@ -26,6 +26,7 @@
 #include "libsi/si.h"
 #include "skins.h"
 #include "tools.h"
+#include "scapmt.h"
 
 // Set these to 'true' for debug output:
 static bool DumpTPDUDataTransfer = false;
@@ -35,6 +36,11 @@ static bool DumpDateTime = false;
 
 #define dbgprotocol(a...) if (DebugProtocol) fprintf(stderr, a)
 
+bool DebugCamtweaks = false; // set by camtweaks.conf
+bool DebugCamtweaksMtd = false; // set by camtweaks.conf
+
+#define DBGCAPMT(a...) if (DebugCamtweaks) dsyslog(a)
+
 // --- Helper functions ------------------------------------------------------
 
 #define SIZE_INDICATOR 0x80
@@ -185,6 +191,7 @@ void cCaPidReceiver::Receive(const uchar
 {
   if (TsPid(Data) == CATPID) {
      cMtdCamSlot *MtdCamSlot = dynamic_cast<cMtdCamSlot *>(Device()->CamSlot());
+     cScaMapper *ScaMapper = Device()->ScaMapper();
      const uchar *p = NULL;
      if (TsPayloadStart(Data)) {
         if (Data[5] == SI::TableIdCAT) {
@@ -203,7 +210,7 @@ void cCaPidReceiver::Receive(const uchar
                     else {
                        p = Data + 5; // no need to copy the data
                        }
-                    if (MtdCamSlot) {
+                    if (MtdCamSlot || ScaMapper) {
                        mtdNumCatPackets = 0;
                        memcpy(mtdCatBuffer[mtdNumCatPackets++], Data, TS_SIZE);
                        }
@@ -212,9 +219,13 @@ void cCaPidReceiver::Receive(const uchar
                     dsyslog("multi table CAT section - unhandled!");
                  catVersion = v;
                  }
-              else if (MtdCamSlot) {
-                 for (int i = 0; i < mtdNumCatPackets; i++)
-                     MtdCamSlot->PutCat(mtdCatBuffer[i], TS_SIZE);
+              else if (MtdCamSlot || ScaMapper) {
+                 for (int i = 0; i < mtdNumCatPackets; i++) {
+                     if (MtdCamSlot)
+                        MtdCamSlot->PutCat(mtdCatBuffer[i], TS_SIZE);
+                     else
+                        Device()->CamSlot()->Inject(mtdCatBuffer[i], TS_SIZE); // use 'Inject' as the ddci2 'Decrypt' function is not thread-save
+                     }
                  }
               }
            }
@@ -229,7 +240,7 @@ void cCaPidReceiver::Receive(const uchar
               p = buffer;
               length = bufp - buffer;
               }
-           if (MtdCamSlot)
+           if (MtdCamSlot || ScaMapper)
               memcpy(mtdCatBuffer[mtdNumCatPackets++], Data, TS_SIZE);
            }
         else {
@@ -248,19 +259,23 @@ void cCaPidReceiver::Receive(const uchar
                   AddEmmPid(EmmPid);
                   if (MtdCamSlot)
                      MtdMapPid(const_cast<uchar *>(p + i + 4), MtdCamSlot->MtdMapper());
+                  if (ScaMapper)
+                     Poke13(const_cast<uchar *>(p + i + 4), ScaMapper->RealToUniqPid(Peek13(p + i + 4)));
                   switch (CaId >> 8) {
                     case 0x01: for (int j = i + 7; j < i + p[i + 1] + 2; j += 4) {
                                    EmmPid = Peek13(p + j);
                                    AddEmmPid(EmmPid);
                                    if (MtdCamSlot)
                                       MtdMapPid(const_cast<uchar *>(p + j), MtdCamSlot->MtdMapper());
+                                   if (ScaMapper)
+                                      Poke13(const_cast<uchar *>(p + j), ScaMapper->RealToUniqPid(Peek13(p + j)));
                                    }
                                break;
                     }
                   i += p[i + 1] + 2 - 1; // -1 to compensate for the loop increment
                   }
                }
-           if (MtdCamSlot) {
+           if (MtdCamSlot || ScaMapper) {
               // update crc32
               uint32_t crc = SI::CRC32::crc32((const char *)p, length - 4, 0xFFFFFFFF); // <TableIdCAT....>[crc32]
               uchar *c = const_cast<uchar *>(p + length - 4);
@@ -275,7 +290,10 @@ void cCaPidReceiver::Receive(const uchar
                   memcpy(mtdCatBuffer[i] + j, t, n);
                   t += n;
                   length -= n;
-                  MtdCamSlot->PutCat(mtdCatBuffer[i], TS_SIZE);
+                  if (MtdCamSlot)
+                     MtdCamSlot->PutCat(mtdCatBuffer[i], TS_SIZE);
+                  else
+                     Device()->CamSlot()->Inject(mtdCatBuffer[i], TS_SIZE);
                   }
               }
            }
@@ -614,6 +632,9 @@ private:
   bool createConnectionRequested;
   bool deleteConnectionRequested;
   bool hasUserIO;
+  cMutex sendTpduMutex;
+  cMutex sendDataMutex;
+  cTimeMs sendTimer;
   cTimeMs alive;
   cTimeMs timer;
   cCiSession *sessions[MAX_SESSIONS_PER_TC + 1]; // session numbering starts with 1
@@ -908,6 +929,23 @@ bool cCiApplicationInformation::EnterMen
   return false;
 }
 
+// --- CamTweaks ---
+
+#define CAMTWEAK_ENABLED   0x1
+#define CAMTWEAK_FORCE_MCD 0x2
+#define CAMTWEAK_AVOID_MTD 0x4
+
+#define CAMTWEAK_PACK_MCD  0x10
+#define CAMTWEAK_PACK_MTD  0x20
+#define CAMTWEAK_STATIC_CAPMT 0x40
+
+#define CAMTWEAK_DESELECT  0x800
+#define CAMTWEAK_DEBUG     0x1000
+#define CAMTWEAK_DBGMTD    0x2000
+
+#define CAMTWEAK_PACK_CAPMT (CAMTWEAK_PACK_MCD | CAMTWEAK_PACK_MTD)
+#define CAMTWEAK_OPTS_CAPMT (CAMTWEAK_PACK_CAPMT | CAMTWEAK_STATIC_CAPMT | CAMTWEAK_DESELECT)
+
 // --- cCiCaPmt --------------------------------------------------------------
 
 #define MAXCASYSTEMIDS 64
@@ -939,22 +977,41 @@ private:
   int transponder;
   int programNumber;
   int caSystemIds[MAXCASYSTEMIDS + 1]; // list is zero terminated!
+  uint32_t camTweaks;
+  uint8_t programCmdId;
+  int esInfoPos;
   void AddCaDescriptors(int Length, const uint8_t *Data);
 public:
-  cCiCaPmt(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds);
+  cCiCaPmt(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds, uint32_t CamTweaks = 0);
   uint8_t CmdId(void) { return cmdId; }
   void SetListManagement(uint8_t ListManagement);
   uint8_t ListManagement(void) { return capmt.Get(0); }
+
+  void UseCmdId(uint8_t CmdId) { cmdId = CmdId; }
+  void UseSourceTransponder(int Source, int Transponder) { source = Source; transponder = Transponder; };
+  void UseProgramNumber(int ProgramNumber) { programNumber = ProgramNumber; };
+  uint8_t ProgramCmdId(void) { return programCmdId; }
+  void SetSid(uint16_t Sid);
+  uint16_t GetSid(void) { return capmt.Get(1) << 8 | capmt.Get(2); }
+
   void AddPid(int Pid, uint8_t StreamType);
+  void AddStaticPids(cVector<uint32_t> &VscaConf, cScaMapper *ScaMapper);
   void MtdMapPids(cMtdMapper *MtdMapper);
+  void MtdMapEsPids(cMtdMapper *MtdMapper);
+
+  cDynamicBuffer *CaPmt(void) { return &capmt; }
+  void DumpCaPmt(void);
   };
 
-cCiCaPmt::cCiCaPmt(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds)
+cCiCaPmt::cCiCaPmt(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds, uint32_t CamTweaks)
 {
   cmdId = CmdId;
   source = Source;
   transponder = Transponder;
   programNumber = ProgramNumber;
+  camTweaks = CamTweaks;
+  programCmdId = CmdId;
+  esInfoPos = 0;
   int i = 0;
   if (CaSystemIds) {
      for (; CaSystemIds[i]; i++)
@@ -969,7 +1026,9 @@ cCiCaPmt::cCiCaPmt(uint8_t CmdId, int So
   esInfoLengthPos = capmt.Length();
   capmt.Append(0x00); // program_info_length H (at program level)
   capmt.Append(0x00); // program_info_length L
-  AddCaDescriptors(caDescriptors.Length(), caDescriptors.Data());
+
+  int cadLen = (camTweaks & CAMTWEAK_PACK_CAPMT) ? 0 : caDescriptors.Length();
+  AddCaDescriptors(cadLen, caDescriptors.Data());
 }
 
 void cCiCaPmt::SetListManagement(uint8_t ListManagement)
@@ -977,10 +1036,22 @@ void cCiCaPmt::SetListManagement(uint8_t
   capmt.Set(0, ListManagement);
 }
 
+void cCiCaPmt::SetSid(uint16_t Sid)
+{
+  capmt.Set(1, (Sid >> 8) & 0xFF);
+  capmt.Set(2,  Sid       & 0xFF);
+}
+
 void cCiCaPmt::AddPid(int Pid, uint8_t StreamType)
 {
   if (Pid) {
+     caDescriptors.Clear(); // should go into cCaDescriptorHandler::GetCaDescriptors()
      GetCaDescriptors(source, transponder, programNumber, caSystemIds, caDescriptors, Pid);
+
+     if (!caDescriptors.Length() && (camTweaks & CAMTWEAK_PACK_CAPMT))
+        GetCaDescriptors(source, transponder, programNumber, caSystemIds, caDescriptors, 0);
+     if (!esInfoPos)
+        esInfoPos = capmt.Length();
      capmt.Append(StreamType);
      capmt.Append((Pid >> 8) & 0xFF);
      capmt.Append( Pid       & 0xFF);
@@ -1007,6 +1078,41 @@ void cCiCaPmt::AddCaDescriptors(int Leng
      esyslog("ERROR: adding CA descriptor without Pid!");
 }
 
+void cCiCaPmt::AddStaticPids(cVector<uint32_t> &VscaConf, cScaMapper *ScaMapper)
+{
+  uint8_t StreamType = 6; // 6: STREAMTYPE_13818_PES_PRIVATE
+  uint8_t caDescriptor[6];
+
+  int s = 0;
+  for (int n = 0; n < VscaConf.Size(); n++) {
+      uint32_t sca = VscaConf[n];
+      int caId = (sca >> 16) & 0xFFFF;
+      int sids = (sca >>  8) & 0xFF;
+      int pids = (sca      ) & 0xFF;
+
+      caDescriptor[0] = SI::CaDescriptorTag;
+      caDescriptor[1] = 4;
+      caDescriptor[2] = (caId >> 8) & 0xFF;
+      caDescriptor[3] =  caId       & 0xFF;
+
+      for (int i = 0; i < sids; i++, s++) {
+          int Ecm = ScaMapper->UniqCaPid(s, 0);
+          caDescriptor[4] = (Ecm >> 8) & 0xFF;
+          caDescriptor[5] =  Ecm       & 0xFF;
+          for (int j = 1; j <= pids; j++) {
+              int Pid = ScaMapper->UniqCaPid(s, j);
+              capmt.Append(StreamType);
+              capmt.Append((Pid >> 8) & 0xFF);
+              capmt.Append( Pid       & 0xFF);
+              esInfoLengthPos = capmt.Length();
+              capmt.Append(0x00); // ES_info_length H (at ES level)
+              capmt.Append(0x00); // ES_info_length L
+              AddCaDescriptors(sizeof(caDescriptor), caDescriptor);
+              }
+          }
+      }
+}
+
 static int MtdMapCaDescriptor(uchar *p, cMtdMapper *MtdMapper)
 {
   // See pat.c: cCaDescriptor::cCaDescriptor() for the layout of the data!
@@ -1066,12 +1172,23 @@ static int MtdMapStreams(uchar *p, cMtdM
   return Length;
 }
 
+void cCiCaPmt::MtdMapEsPids(cMtdMapper *MtdMapper)
+{
+  if (esInfoPos) {
+     uchar *p = capmt.Data() + esInfoPos;
+     int m = capmt.Length() - esInfoPos;
+     MtdMapStreams(p, MtdMapper, m);
+     esInfoPos = 0;
+     }
+}
+
 void cCiCaPmt::MtdMapPids(cMtdMapper *MtdMapper)
 {
   uchar *p = capmt.Data();
   int m = capmt.Length();
   if (m >= 3) {
-     MtdMapSid(p + 1, MtdMapper);
+     if (!(camTweaks & CAMTWEAK_PACK_CAPMT)) // PACK_CAPMT: no Sid mapping required
+        MtdMapSid(p + 1, MtdMapper);
      p += 4;
      m -= 4;
      if (m >= 2) {
@@ -1085,6 +1202,63 @@ void cCiCaPmt::MtdMapPids(cMtdMapper *Mt
      }
 }
 
+//------ DUMP CAPMT
+
+static int DumpCaDescriptors(uchar *p, char *s)
+{
+  int Length = p[0] * 256 + p[1];
+  if (Length >= 1) {
+     uint8_t CmdId = p[2];
+     s += sprintf(s, "{%d}", CmdId);
+     p += 3;
+     int m = Length - 1;
+     for (int l = m; m > 0 && *p == SI::CaDescriptorTag; m -= l, p += l) {
+         l = p[1] + 2;
+         if (l >= 6) {
+            uint16_t caid = p[2] << 8 | p[3];
+            uint16_t ecm = Peek13(p + 4);
+            s += sprintf(s, "<%d(%X)/%d(%X)>", caid, caid, ecm, ecm);
+            }
+         else
+            break;
+         }
+     }
+  return Length + 2;
+}
+
+static int DumpStreams(uchar *p, int Length, char *q)
+{
+  char *s = q + strlen(q);
+  int m = Length;
+  for (int l = 0; m >= 5; m -= l, p += l) {
+      uint16_t Pid = Peek13(p + 1);
+      s += sprintf(s, " ES:%d(%X)", Pid, Pid);
+
+      l = 3 + DumpCaDescriptors(p + 3, s);
+      s += strlen(s);
+      }
+  return Length;
+}
+
+void cCiCaPmt::DumpCaPmt(void)
+{
+  char info[4000] = { 0 };
+  uchar *p = capmt.Data();
+  int m = capmt.Length();
+  if (m >= 3) {
+     char *q = info;
+     uint8_t Lm = capmt.Get(0);
+     uint16_t Sid = GetSid();
+     q += sprintf(q, "[%d] PL:%d(%X)", Lm, Sid, Sid);
+
+     if (m >= 6) {
+        int l = 4 + DumpCaDescriptors(p + 4, q);
+        DumpStreams(p + l, m - l, q);
+        }
+     dsyslog("%s", info);
+     }
+}
+
 // --- cCiConditionalAccessSupport -------------------------------------------
 
 // CA Enable Ids:
@@ -1111,11 +1285,13 @@ private:
   bool repliesToQuery;
   cTimeMs timer;
   int numRetries;
+  bool applyCamTweaks;
 public:
   cCiConditionalAccessSupport(uint16_t SessionId, cCiTransportConnection *Tc);
   virtual void Process(int Length = 0, const uint8_t *Data = NULL);
   const int *GetCaSystemIds(void) { return caSystemIds; }
   void SendPMT(cCiCaPmt *CaPmt);
+  bool ApplyCamTweaks(void); /// CA Module tweaking
   bool RepliesToQuery(void) { return repliesToQuery; }
   bool Ready(void) { return state >= 4; }
   bool ReceivedReply(void) { return state >= 5; }
@@ -1130,6 +1306,7 @@ cCiConditionalAccessSupport::cCiConditio
   caSystemIds[numCaSystemIds = 0] = 0;
   repliesToQuery = false;
   numRetries = 0;
+  applyCamTweaks = Setup.EnableCamTweaks;
 }
 
 void cCiConditionalAccessSupport::Process(int Length, const uint8_t *Data)
@@ -1162,6 +1339,10 @@ void cCiConditionalAccessSupport::Proces
                timer.Set(0);
                numRetries = QUERY_RETRIES;
                state = 2; // got ca info
+               if (numCaSystemIds == 1 && caSystemIds[0] == 0xFFFF) { // dvbapi 'wildcard' CAID
+                  dsyslog("CAM %d: virtual CAM detected", CamSlot()->SlotNumber());
+                  applyCamTweaks = false;
+                  }
                }
             dsyslog("CAM %d: system ids:%s", CamSlot()->SlotNumber(), *Ids ? *Ids : " none");
             }
@@ -1235,8 +1416,19 @@ void cCiConditionalAccessSupport::Proces
      SendData(AOT_CA_INFO_ENQ);
      state = 1; // enquired ca info
      }
-  else if ((state == 2 || state == 3) && timer.TimedOut()) {
-     if (numRetries-- > 0) {
+  else if (!applyCamTweaks && (state == 2 || state == 3) && timer.TimedOut()) {
+     if (CamSlot()->McdForced()) {
+        if (CamSlot()->IsMasterSlot())
+           dsyslog("CAM %d: multi channel decryption (MCD) forced by Setup!", CamSlot()->SlotNumber());
+        if (CamSlot()->MtdAvailable()) {
+           bool use_mtd = !(CamSlot()->GetCamTweakFlags() & CAMTWEAK_AVOID_MTD);
+           if (CamSlot()->IsMasterSlot())
+              dsyslog("CAM %d: supports multi transponder decryption (MTD) %s", CamSlot()->SlotNumber(), use_mtd ? "" : "! disabled by Setup !");
+           CamSlot()->MtdActivate(use_mtd);
+           }
+        state = 4; // normal operation
+        }
+     else if (numRetries-- > 0) {
         cCiCaPmt CaPmt(CPCI_QUERY, 0, 0, 0, NULL);
         SendPMT(&CaPmt);
         timer.Set(QUERY_WAIT_TIME);
@@ -1248,17 +1440,106 @@ void cCiConditionalAccessSupport::Proces
         state = 4; // normal operation
         }
      }
+  else if (applyCamTweaks && state == 2) { // configure MCD/MTD
+     applyCamTweaks = !ApplyCamTweaks();
+     }
 }
 
 void cCiConditionalAccessSupport::SendPMT(cCiCaPmt *CaPmt)
 {
   if (CaPmt && state >= 2) {
+     CamSlot()->CaPmtTracker(CaPmt);
      dbgprotocol("Slot %d: ==> Ca Pmt (%d) %d %d\n", CamSlot()->SlotNumber(), SessionId(), CaPmt->ListManagement(), CaPmt->CmdId());
      SendData(AOT_CA_PMT, CaPmt->capmt.Length(), CaPmt->capmt.Data());
      state = 4; // sent ca pmt
      }
 }
 
+// --- CamTweaks ---
+
+bool cCiConditionalAccessSupport::ApplyCamTweaks(void)
+{
+  cCiApplicationInformation *ai = (cCiApplicationInformation *)CamSlot()->GetSessionByResourceId(RI_APPLICATION_INFORMATION);
+  if (!ai || !ai->GetMenuString()) {
+     esyslog("CAM %d: wait for ApplicationInformtion", CamSlot()->SlotNumber());
+     return false;
+     }
+
+  // search ca-module in configfile
+  cCaModuleTweak *cmt = CaModuleTweaks.GetEntry(ai->GetApplicationManufacturer(), ai->GetManufacturerCode(), ai->GetMenuString());
+  if (!cmt) // add it to the configfile, untweaked
+     cmt = CaModuleTweaks.AddEntry(ai->GetApplicationManufacturer(), ai->GetManufacturerCode(), ai->GetMenuString(), 0x0, 0, NULL);
+  /// assign the tweaks to the camslot only if they are enabled in setup AND flags
+  bool enabled = (Setup.EnableCamTweaks && cmt->CamFlags() & CAMTWEAK_ENABLED);
+  uint32_t Flags = enabled ? cmt->CamFlags() : 0x0;
+  int Limit = enabled ? cmt->McdLimit() : 0;
+
+  if (Flags & CAMTWEAK_FORCE_MCD) {
+     if (Flags & CAMTWEAK_STATIC_CAPMT)
+        Flags &= ~CAMTWEAK_PACK_CAPMT;
+     else if (Flags & CAMTWEAK_PACK_CAPMT) {
+        uint32_t f = Flags;
+        Flags &= ~CAMTWEAK_PACK_CAPMT;
+        Flags |= (f & CAMTWEAK_PACK_MTD) ? CAMTWEAK_PACK_MTD : CAMTWEAK_PACK_MCD;
+        }
+     }
+  else
+     Flags &= ~(CAMTWEAK_PACK_CAPMT | CAMTWEAK_STATIC_CAPMT);
+
+  // enable debuging
+  DebugCamtweaks    = Flags & CAMTWEAK_DEBUG;
+  DebugCamtweaksMtd = Flags & CAMTWEAK_DBGMTD;
+
+  // parse static CaIds
+  if (Flags & CAMTWEAK_STATIC_CAPMT) {
+     cVector<uint32_t> &vScaConf = cmt->VscaConf();
+     cVector<int> caIds;
+
+     for (int i = 0; i < vScaConf.Size(); i++) {
+         int caId = (vScaConf[i] >> 16) & 0xFFFF;
+         if (!caId)
+            continue;
+         bool found = false;
+         for (int n = 0; n < numCaSystemIds && !found; n++)
+             found = caSystemIds[n] == caId;
+         if (found)
+            caIds.AppendUnique(caId);
+         else
+            esyslog("CAM %d: static CaId %04X not in CA_INFO", CamSlot()->SlotNumber(), caId);
+         }
+     if (caIds.Size()) { // reduce caSystemIds
+        int n = 0;
+        for (; n < caIds.Size(); n++)
+            caSystemIds[n] = caIds[n];
+        caSystemIds[n] = 0; // zero terminated
+        numCaSystemIds = n;
+     }
+     else {
+        esyslog("CAM %d: no usable static CaId given - STATIC_CAPMT disabled", CamSlot()->SlotNumber());
+        Flags &= ~CAMTWEAK_STATIC_CAPMT;
+        }
+     }
+  //
+  CamSlot()->SetCamTweakFlags(Flags);
+
+  if (Flags & CAMTWEAK_STATIC_CAPMT)
+     Limit = CamSlot()->InitStaticCaPmt(cmt->VscaConf());
+  CamSlot()->SetCamTweakMcdLimit(Limit);
+
+  if (Setup.EnableCamTweaks)
+     dsyslog("CAM %d: Tweaks [%s]: Flags: 0x%X, Limit: %d (%s%s%s%s%s)", CamSlot()->SlotNumber(),
+                      cmt->CamFlags() & CAMTWEAK_ENABLED ? "enabled" : "disabled", cmt->CamFlags(), Limit,
+                      (Flags & CAMTWEAK_PACK_MTD) ? "PACK MCD/MTD":
+                      (Flags & CAMTWEAK_PACK_MCD) ? "PACK MCD":
+                      (Flags & CAMTWEAK_FORCE_MCD) ? "MCD" : "",
+
+                      (Flags & CAMTWEAK_STATIC_CAPMT) ? " STATIC": "",
+                      (Flags & CAMTWEAK_DESELECT) ? " DESELECT" : "",
+                      (Flags & CAMTWEAK_DEBUG) ? " DEBUG" : "",
+                      (Flags & CAMTWEAK_DBGMTD) ? " DBGMTD" : "");
+  return true;
+}
+
 // --- cCiHostControl --------------------------------------------------------
 
 class cCiHostControl : public cCiSession {
@@ -1850,15 +2131,30 @@ const char *cCiTransportConnection::GetC
   return ai ? ai->GetMenuString() : NULL;
 }
 
+#define TC_MIN_REMAIN       5 // ms
+#define TC_TPDU_INTERVAL    0 // ms - min. interval for processing TPDUs
+#define TC_CAPMT_INTERVAL 300 // ms - min. interval for processing CA_PMT objects
+
 void cCiTransportConnection::SendTPDU(uint8_t Tag, int Length, const uint8_t *Data)
 {
+  cMutexLock MutexLock(&sendTpduMutex); // may be accessed from different threads
   cTPDU TPDU(camSlot->SlotIndex(), tcid, Tag, Length, Data);
+  int remain = -(int)sendTimer.Elapsed(); // remain is a negtive value
+  int aoTag = Length ? Data[4] << 16 | Data[5] << 8 | Data[6] : 0;
+  if (aoTag)
+     DBGCAPMT("+++++++ SendData Tag: %06X (L:%d.)", aoTag, Length);
+  if (remain >= TC_MIN_REMAIN) {
+     DBGCAPMT("======= SendTPDU Tag: %02X (L:%d.) ==> remain %d ms", Tag, Length, remain);
+     cCondWait::SleepMs(remain);
+     }
   camSlot->Write(&TPDU);
   timer.Set(TC_POLL_TIMEOUT);
+  sendTimer.Set(aoTag == AOT_CA_PMT ? TC_CAPMT_INTERVAL : TC_TPDU_INTERVAL); // Workaround to give some CAMs more time to handle CA_PMTs
 }
 
 void cCiTransportConnection::SendData(int Length, const uint8_t *Data)
 {
+  cMutexLock MutexLock(&sendDataMutex); // may be accessed from different threads
   // if Length ever exceeds MAX_TPDU_DATA this needs to be handled differently
   if (state == stACTIVE && Length > 0)
      SendTPDU(T_DATA_LAST, Length, Data);
@@ -2184,6 +2480,18 @@ cCamSlot::cCamSlot(cCiAdapter *CiAdapter
   lastModuleStatus = msReset; // avoids initial reset log message
   resetTime = 0;
   resendPmt = false;
+
+  camTweakFlags = 0x0;  // set in MasterSlot by cCiConditionalAccessSupport
+  camTweakMcdLimit = 0;
+
+  activeProgsPrev = 0;
+  activeProgs = 0;
+  activePids = 0;
+  caplActive = false;
+  caplModified = false;
+
+  scaMapper = NULL;
+
   for (int i = 0; i <= MAX_CONNECTIONS_PER_CAM_SLOT; i++) // tc[0] is not used, but initialized anyway
       tc[i] = NULL;
   if (MasterSlot)
@@ -2204,6 +2512,8 @@ cCamSlot::~cCamSlot()
   CamSlots.Del(this, false);
   DeleteAllConnections();
   delete mtdHandler;
+  if (!masterSlot)
+     delete scaMapper;
 }
 
 cCamSlot *cCamSlot::MtdSpawn(void)
@@ -2343,12 +2653,21 @@ void cCamSlot::Process(cTPDU *TPDU)
      moduleCheckTimer.Set(MODULE_CHECK_INTERVAL);
      }
   if (resendPmt && Ready()) {
+     ResetCaPmtTracker();
+     DBGCAPMT("CAM %d/%d: resend ProgramList", slotNumber, MtdNumber());
      if (mtdHandler) {
-        mtdHandler->StartDecrypting();
-        resendPmt = false;
+        if (!CaPmtPack())
+           mtdHandler->StartDecrypting();
+        else {
+           // !! this is ddci2 specific code !!
+           // No forewarding to the base class cCamSlot::StartDecrypting() by ddci2 in MTD mode
+           StartDecrypting();
+           cCamSlot::StartDecrypting();
+           }
         }
      else if (caProgramList.Count())
         StartDecrypting();
+     resendPmt = false;
      }
   processed.Broadcast();
 }
@@ -2500,9 +2819,9 @@ cCiCaPmtList::~cCiCaPmtList()
       delete caPmts[i];
 }
 
-cCiCaPmt *cCiCaPmtList::Add(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds)
+cCiCaPmt *cCiCaPmtList::Add(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds, uint32_t CamTweaks)
 {
-  cCiCaPmt *p = new cCiCaPmt(CmdId, Source, Transponder, ProgramNumber, CaSystemIds);
+  cCiCaPmt *p = new cCiCaPmt(CmdId, Source, Transponder, ProgramNumber, CaSystemIds, CamTweaks);
   caPmts.Append(p);
   return p;
 }
@@ -2513,6 +2832,11 @@ void cCiCaPmtList::Del(cCiCaPmt *CaPmt)
      delete CaPmt;
 }
 
+cDynamicBuffer *cCiCaPmtList::CaPmt(int Index)
+{
+  return caPmts[Index]->CaPmt();
+}
+
 bool cCamSlot::RepliesToQuery(void)
 {
   cMutexLock MutexLock(&mutex);
@@ -2520,21 +2844,164 @@ bool cCamSlot::RepliesToQuery(void)
   return cas && cas->RepliesToQuery();
 }
 
+bool cCamSlot::McdForced(void)
+{
+  return GetCamTweakFlags() & CAMTWEAK_FORCE_MCD;
+}
+
+uint32_t cCamSlot::CaPmtPackStatic(void)
+{
+  return GetCamTweakFlags() & (CAMTWEAK_PACK_CAPMT | CAMTWEAK_STATIC_CAPMT);
+}
+
+uint32_t cCamSlot::CaPmtPack(void)
+{
+  return GetCamTweakFlags() & CAMTWEAK_PACK_CAPMT;
+}
+
+bool cCamSlot::CaPmtPackMtd(void)
+{
+  return GetCamTweakFlags() & CAMTWEAK_PACK_MTD;
+}
+
+bool cCamSlot::CaPmtStatic(void)
+{
+  return GetCamTweakFlags() & CAMTWEAK_STATIC_CAPMT;
+}
+
+///----- CAM serviceList Tracker -----
+
+void cCamSlot::ResetCaPmtTracker()
+{
+  serviceSlots.Clear();
+  serviceSlotCmdIds.Clear();
+  serviceSlotActives.Clear();
+}
+
+void cCamSlot::CaPmtTracker(cCiCaPmt *CaPmt)
+{
+  char svc[1000] = { 0 };
+  char *q = svc;
+  if (DebugCamtweaks)
+     CaPmt->DumpCaPmt();
+
+  uint8_t Lm = CaPmt->ListManagement();
+  uint16_t Sid = CaPmt->GetSid();
+  uint8_t CmdId = CaPmt->CmdId();
+
+  if (Lm == CPLM_ONLY || Lm == CPLM_FIRST)
+     ResetCaPmtTracker();
+  if (Sid) { // Is 0 a valid service number ?
+     int i = serviceSlots.IndexOf(Sid);
+     if (i < 0) {
+        serviceSlots.Append(Sid);
+        serviceSlotCmdIds.Append(CmdId);
+        }
+     else
+        serviceSlotCmdIds[i] = CmdId; // update
+
+     serviceSlotActives.Clear();
+     for (i = 0; i < serviceSlots.Size(); i++) {
+         q += sprintf(q, " [%d:%d(%04X){%d}]", i+1, serviceSlots[i], serviceSlots[i], serviceSlotCmdIds[i]);
+         if (serviceSlotCmdIds[i] != CPCI_NOT_SELECTED)
+            serviceSlotActives.Append(serviceSlots[i]);
+         }
+     }
+  DBGCAPMT("----- %s: Service <%d/%d>: %s", __func__, serviceSlotActives.Size(), serviceSlots.Size(), svc);
+}
+
+int cCamSlot::NumCamServices(void)
+{
+  return serviceSlots.Size();
+}
+
+bool cCamSlot::IsCamService(uint16_t Sid)
+{
+  return serviceSlots.IndexOf(Sid) >= 0;
+}
+
+///-----
+
+int cCamSlot::GetCaPmtSid(int Sid, int MtdNumber)
+{
+  uint32_t caPmtPack = CaPmtPackStatic();
+  return ((!caPmtPack) ? Sid : SlotNumber() * 1000) + (caPmtPack & CAMTWEAK_PACK_MCD ? MtdNumber : 0);
+}
+
+const char *ListMMs[6] = { "CPLM_MORE", "CPLM_FIRST", "CPLM_LAST", "CPLM_ONLY", "CPLM_ADD", "CPLM_UPDATE" };
+const char *CmdIds[5] = { "undef", "ok_descrambling", "ok_mmi", "query", "not_selected" };
+
+int cCamSlot::InitStaticCaPmt(cVector<uint32_t> &VscaConf)
+{
+  if (!IsMasterSlot())
+     return 0;
+  delete scaMapper; // create new
+  scaMapper = new cScaMapper(VscaConf, this);
+  return scaMapper->NumSids();
+}
+
+bool cCamSlot::SendStaticCaPmt(cVector<uint32_t> &VscaConf)
+{
+  if (!scaMapper)
+     return false;
+  int Sid = 1; // any
+  cCiCaPmtList CaPmtList;
+  // prepare a packed CAPMT
+  cCiCaPmt *CaPmt = CaPmtList.Add(CPCI_OK_DESCRAMBLING, 0, 0, Sid, NULL, CAMTWEAK_PACK_MTD);
+  CaPmt->AddStaticPids(VscaConf, scaMapper);
+  CaPmt->SetSid(GetCaPmtSid(Sid));
+  cCiConditionalAccessSupport *cas = (cCiConditionalAccessSupport *)GetSessionByResourceId(RI_CONDITIONAL_ACCESS_SUPPORT);
+  if (cas)
+     cas->SendPMT(CaPmtList.caPmts[0]);
+  return cas != NULL;
+}
+
 void cCamSlot::BuildCaPmts(uint8_t CmdId, cCiCaPmtList &CaPmtList, cMtdMapper *MtdMapper)
 {
   cMutexLock MutexLock(&mutex);
-  CaPmtList.caPmts.Clear();
+
+  uint32_t caPmtOpts = GetCamTweakFlags() & CAMTWEAK_OPTS_CAPMT;
+  uint32_t caPmtPack = CaPmtPack();
+
+  cCiCaPmt *CaPmt = ((caPmtPack & CAMTWEAK_PACK_MTD) && CaPmtList.caPmts.Size()) ? CaPmtList.caPmts[0] : NULL; // PACK_MTD: append to existing CaPmt
+  if (CaPmt)
+     CaPmt->UseSourceTransponder(source, transponder); // PACK_MTD: switch to source and transponder of this MtdCamSlot
+  else
+     CaPmtList.caPmts.Clear();
+
   const int *CaSystemIds = GetCaSystemIds();
   if (CaSystemIds && *CaSystemIds) {
+     activeProgsPrev = activeProgs;
+     activeProgs = 0;
+     activePids = 0;
      if (caProgramList.Count()) {
         for (cCiCaProgramData *p = caProgramList.First(); p; p = caProgramList.Next(p)) {
-            if (p->modified || resendPmt) {
-               bool Active = p->Active();
-               cCiCaPmt *CaPmt = CaPmtList.Add(Active ? CmdId : CPCI_NOT_SELECTED, source, transponder, p->programNumber, CaSystemIds);
+            bool Active = p->Active();
+            if (p->modified || resendPmt || (caPmtPack && caplModified)) {
+
+               if (!caPmtPack) // VDR default
+                  CaPmt = CaPmtList.Add(Active ? CmdId : CPCI_NOT_SELECTED, source, transponder, p->programNumber, CaSystemIds);
+               else {          // PACK_CAPMT
+                  if (!CaPmt) {
+                     CaPmt = CaPmtList.Add(caplActive ? CmdId : CPCI_NOT_SELECTED, source, transponder, p->programNumber, CaSystemIds, caPmtPack);
+                     CaPmt->SetSid(GetCaPmtSid(p->programNumber));
+                     }
+                  else
+                     CaPmt->UseProgramNumber(p->programNumber); // PACK_MCD/PACK_MTD: switch the programNumber for ca-descriptors
+                  }
+               uint16_t CaPmtSid = CaPmt->GetSid();
+               DBGCAPMT("%s CAM %d/%d: Sid %d (%X) -> %d (%X) %s", __func__, SlotNumber(), MtdNumber(), p->programNumber, p->programNumber, CaPmtSid, CaPmtSid, resendPmt ? "*resend*" : "");
+
                for (cCiCaPidData *q = p->pidList.First(); q; q = p->pidList.Next(q)) {
-                   if (q->active)
+                   if (q->active || (p->modified && (caPmtOpts & CAMTWEAK_DESELECT))) {
+                      CaPmt->UseCmdId(q->active ? CmdId : CPCI_NOT_SELECTED);
                       CaPmt->AddPid(q->pid, q->streamType);
+                      }
+                   DBGCAPMT("%s CAM %d/%d: Pid %d (%X) %s", __func__, SlotNumber(), MtdNumber(), q->pid, q->pid,
+                            q->active ? p->modified ? "+" : "#" : p->modified && (caPmtOpts & CAMTWEAK_DESELECT) ? "-" : ".");
                    }
+               CaPmt->UseCmdId(CaPmt->ProgramCmdId()); // restore the CmdId at program-level in case AddPid() has changed it
+
                if (caPidReceiver) {
                   int CaPids[MAXRECEIVEPIDS + 1];
                   if (GetCaPids(source, transponder, p->programNumber, CaSystemIds, MAXRECEIVEPIDS + 1, CaPids) > 0) {
@@ -2546,17 +3013,42 @@ void cCamSlot::BuildCaPmts(uint8_t CmdId
                         }
                      }
                   }
-               if (RepliesToQuery())
-                  CaPmt->SetListManagement(Active ? CPLM_ADD : CPLM_UPDATE);
-               if (MtdMapper)
-                  CaPmt->MtdMapPids(MtdMapper);
+               if (!caPmtPack) {
+                  if (McdAvailable())
+                     CaPmt->SetListManagement(Active ? CPLM_ADD : CPLM_UPDATE);
+                  if (MtdMapper)
+                     CaPmt->MtdMapPids(MtdMapper);
+                  }
+               else if (p == caProgramList.Last()) {
+                  if (MasterSlot()->NumCamServices() && McdAvailable())
+                     CaPmt->SetListManagement(MasterSlot()->IsCamService(CaPmtSid) ? CPLM_UPDATE : CPLM_ADD);
+                  if (MtdMapper)
+                     CaPmt->MtdMapEsPids(MtdMapper); // Stream Es/ECM-Pids only
+                  }
+
+               if (!caPmtPack || p == caProgramList.Last())
+                  DBGCAPMT("%s CAM %d/%d: ListManagement %s", __func__, SlotNumber(), MtdNumber(), ListMMs[CaPmt->ListManagement()]);
                p->modified = false;
                }
+            if (Active) { // update CAM-stats
+               activeProgs++;
+               int pidLimit = scaMapper ? scaMapper->NumPids() : 0;
+               int i = 0;
+               for (cCiCaPidData *q = p->pidList.First(); q; q = p->pidList.Next(q)) {
+                   if (q->active && (!pidLimit || i < pidLimit)) {
+                      activePids++;
+                      i++;
+                      }
+                   }
+               }
             }
         }
      else if (CmdId == CPCI_NOT_SELECTED)
-        CaPmtList.Add(CmdId, 0, 0, 0, NULL);
+        CaPmt = CaPmtList.Add(CmdId, 0, 0, 0, NULL);
      }
+  if (CaPmt)
+     DBGCAPMT("%s CAM %d/%d: [%s] ActiveProgs: %d of %d (%d Pids)", __func__, SlotNumber(), MtdNumber(),
+                             CmdIds[CaPmt->CmdId()], activeProgs, caProgramList.Count(), activePids);
 }
 
 void cCamSlot::KeepSharedCaPids(int ProgramNumber, const int *CaSystemIds, int *CaPids)
@@ -2601,15 +3093,32 @@ void cCamSlot::SendCaPmts(cCiCaPmtList &
   cMutexLock MutexLock(&mutex);
   cCiConditionalAccessSupport *cas = (cCiConditionalAccessSupport *)GetSessionByResourceId(RI_CONDITIONAL_ACCESS_SUPPORT);
   if (cas) {
-     for (int i = 0; i < CaPmtList.caPmts.Size(); i++)
-         cas->SendPMT(CaPmtList.caPmts[i]);
+     if (scaMapper) {
+        scaMapper->MapStaticCaPmts(CaPmtList);
+        }
+     else {
+        for (int i = 0; i < CaPmtList.caPmts.Size(); i++)
+            cas->SendPMT(CaPmtList.caPmts[i]);
+        }
+     if (mtdHandler) {
+        activeProgsPrev = mtdHandler->CamActiveProgsPrev();
+        activeProgs = mtdHandler->CamActiveProgs();
+        activePids = mtdHandler->CamActivePids();
+        }
+     dsyslog("%s CAM %d: [%d] actives in CAM: %d -> %d (%d pids)", __func__,
+                 SlotNumber(), CaPmtList.caPmts.Size(), activeProgsPrev, activeProgs, activePids);
      }
-  resendPmt = false;
 }
 
 void cCamSlot::SendCaPmt(uint8_t CmdId)
 {
   cMutexLock MutexLock(&mutex);
+  caplActive = CaProgramListActive();
+  caplModified = CaProgramListModified();
+  if (mtdHandler) {
+     mtdHandler->SendCaPmt(CmdId, this, resendPmt);
+     return;
+     }
   cCiCaPmtList CaPmtList;
   BuildCaPmts(CmdId, CaPmtList);
   SendCaPmts(CaPmtList);
@@ -2628,6 +3137,7 @@ void cCamSlot::MtdActivate(bool On)
            dsyslog("CAM %d: activating MTD support", SlotNumber());
            mtdHandler = new cMtdHandler;
            }
+           mtdHandler->SetScaMapper(scaMapper); // Set or Update
         }
      else if (mtdHandler) {
         dsyslog("CAM %d: deactivating MTD support", SlotNumber());
@@ -2657,6 +3167,28 @@ int cCamSlot::Priority(void)
   return d ? d->Priority() : IDLEPRIORITY;
 }
 
+bool cCamSlot::CaProgramListActive(void)
+{
+  if (mtdHandler)
+     return mtdHandler->CaProgramListActive();
+  for (cCiCaProgramData *p = caProgramList.First(); p; p = caProgramList.Next(p)) {
+      if (p->Active())
+         return true;
+      }
+  return false;
+}
+
+bool cCamSlot::CaProgramListModified(void)
+{
+  if (mtdHandler)
+     return mtdHandler->CaProgramListModified();
+  for (cCiCaProgramData *p = caProgramList.First(); p; p = caProgramList.Next(p)) {
+      if (p->modified)
+         return true;
+      }
+  return false;
+}
+
 bool cCamSlot::ProvidesCa(const int *CaSystemIds)
 {
   cMutexLock MutexLock(&mutex);
@@ -2692,6 +3224,8 @@ void cCamSlot::AddPid(int ProgramNumber,
 
 void cCamSlot::SetPid(int Pid, bool Active)
 {
+  if (scaMapper)
+     scaMapper->SetPid(Pid, Active);
   if (caPidReceiver && caPidReceiver->HandlingPid())
      return;
   cMutexLock MutexLock(&mutex);
@@ -2737,6 +3271,19 @@ bool cCamSlot::CanDecrypt(const cChannel
 {
   if (Channel->Ca() < CA_ENCRYPTED_MIN)
      return true; // channel not encrypted
+  if (camTweakFlags & CAMTWEAK_FORCE_MCD) {
+     bool ok = !camTweakMcdLimit; // any limit ?
+     if (!ok) {
+        int caPmtSid = GetCaPmtSid(Channel->Sid(), MtdMapper ? MtdMapperNumber(MtdMapper) : 0 );
+        if (CaPmtPackMtd() || CaPmtStatic()) // limit is the number of programs packed into one single CA_PMT/Service
+           ok = camTweakMcdLimit > activeProgs;
+        else // limit is the known number of unique CA_PMTs/Services which are accepted by the CAM
+           ok = camTweakMcdLimit > serviceSlotActives.Size() || IsCamService(caPmtSid);
+        DBGCAPMT("CAM %d: %s(%d/%d%s) limit %d - active %d -> %s", SlotNumber(), __func__, Channel->Sid(), caPmtSid, IsCamService(caPmtSid) ? "*" : "-",
+                                  camTweakMcdLimit, (CaPmtPackMtd() || CaPmtStatic()) ? activeProgs : serviceSlotActives.Size(), ok ? "TRUE" : "FALSE");
+        }
+     return ok;
+     }
   if (!IsDecrypting())
      return true; // any CAM can decrypt at least one channel
   cMutexLock MutexLock(&mutex);
@@ -2806,6 +3353,33 @@ bool cCamSlot::IsDecrypting(void)
   return false;
 }
 
+uchar *cCamSlot::ScaMapDecrypt(uchar *Data, int &Count)
+{
+  uchar *d;
+  // Send data to CAM
+  if (Count >= TS_SIZE) {
+     Count = TS_SIZE;
+     int realPid = TsPid(Data);
+     Data = scaMapper->TsPreProcess(Data, Count); // unwanted Pid: Data == NULL, Count == TS_SIZE
+     d = Decrypt(Data, Count);
+     if (Count == 0)
+        TsSetPid(Data, realPid); // must restore PID for later retry
+     }
+  else {
+     Count = 0;
+     d = Decrypt(Data, Count);
+     }
+  // Remap received decrypted data
+  if (d) {
+     int uniqPid = TsPid(d);
+     if (SCAMAPPED(uniqPid))
+        TsSetPid(d, scaMapper->UniqToRealPid(uniqPid));
+     else
+        return NULL; // Injected CAM data or garbagge - need not be returned to device
+     }
+  return d;
+}
+
 uchar *cCamSlot::Decrypt(uchar *Data, int &Count)
 {
   if (Data)
@@ -3098,6 +3672,166 @@ void cChannelCamRelations::Save(void)
          }
      f.Close();
      }
+  else
+     LOG_ERROR_STR(*fileName);
+}
+
+// --- cCaModuleTweak ---------------------------------------------------
+
+cCaModuleTweak::cCaModuleTweak(uint16_t Manuf, uint16_t Mcode, const char *Mname)
+{
+  camManuf = Manuf;
+  camMcode = Mcode;
+  camName  = strdup(Mname);
+  camFlags = 0x0;
+  mcdLimit = 0;
+  scaConf  = NULL;
+}
+
+cCaModuleTweak::~cCaModuleTweak()
+{
+  free(camName);
+  free(scaConf);
+}
+
+void cCaModuleTweak::Set(uint32_t Flags, int Limit, char *ScaConf)
+{
+  camFlags = Flags;
+  mcdLimit = Limit;
+  if (ScaConf) {
+     scaConf = strdup(ScaConf);
+     SetSca();
+     }
+}
+
+void cCaModuleTweak::SetSca(void)
+{
+  vScaConf.Clear();
+  for (char *s = scaConf; s && *s; ) {
+      uint16_t caId = 0;
+      int numSids = 0;
+      int numPids = 0;
+
+      int n = sscanf(s, "%hX:%d:%d", &caId, &numSids, &numPids);
+      if (n == 3) {
+         uint32_t sca = caId << 16 | min(numSids, 255) << 8 | min(numPids, 255);
+         dsyslog("SetSca[%s]: %X,%d,%d = %08X", s, caId, numSids, numPids, sca);
+         vScaConf.Append(sca);
+         }
+      else {
+         dsyslog("SetSca[%s]: Bad format!", s);
+         }
+      if (s = strchr(s, ','))
+         s++;
+      }
+}
+
+// --- cCaModuleTweaks ---------------------------------------------------
+
+cCaModuleTweaks CaModuleTweaks;
+
+cCaModuleTweak *cCaModuleTweaks::GetEntry(uint16_t Manuf, uint16_t Mcode, const char *Mname)
+{
+  cMutexLock MutexLock(&mutex);
+  cCaModuleTweak *cmt = NULL;
+  for (cmt = First(); cmt; cmt = Next(cmt)) {
+      if (cmt->Match(Manuf, Mcode, Mname))
+         return cmt;
+      }
+  return NULL;
+}
+
+cCaModuleTweak *cCaModuleTweaks::AddEntry(uint16_t Manuf, uint16_t Mcode, const char *Mname, uint32_t Flags, int Limit, char *ScaConf)
+{
+  cMutexLock MutexLock(&mutex);
+  cCaModuleTweak *cmt = GetEntry(Manuf, Mcode, Mname);
+  if (!cmt)
+     Add(cmt = new cCaModuleTweak(Manuf, Mcode, Mname));
+  cmt->Set(Flags, Limit, ScaConf);
+  return cmt;
+}
+
+void cCaModuleTweaks::Load(const char *FileName)
+{
+  cMutexLock MutexLock(&mutex);
+  fileName = FileName;
+  if (access(fileName, R_OK) == 0) {
+     dsyslog("loading %s", *fileName);
+     if (FILE *f = fopen(fileName, "r")) {
+        cReadLine ReadLine;
+        char *s;
+
+        uint16_t manuf;
+        uint16_t mcode;
+        uint32_t flags;
+        int      limit;
+
+        while ((s = ReadLine.Read(f)) != NULL) {
+              char *p = strchr(s, '#');
+              if (p)
+                 *p = 0;
+              char *mname = NULL;
+              char *sCaConf = NULL;
+              //int n = sscanf(s, "%X,%d,<%hX:%hX,%m[^>]>,\[%hX,%d,%d]", &flags, &limit, &manuf, &mcode, &mname, &caId, &numSids, &numPids);
+              int n = sscanf(s, "%X,%d,<%hX:%hX,%m[^>]>,[%m[^]]]", &flags, &limit, &manuf, &mcode, &mname, &sCaConf);
+              if (n == 6 || n == 5) // V 2.4 || V 1.0 - 2.3
+                 AddEntry(manuf, mcode, mname, flags, limit, sCaConf);
+              free(mname);
+              free(sCaConf);
+              }
+        fclose(f);
+        }
+     else
+        LOG_ERROR_STR(*fileName);
+     }
+}
+
+void cCaModuleTweaks::Save(void)
+{
+  char help[] = 
+                "# ---  CaModule-Tweaks configfile (experimental) V.2.4 ---\n" \
+                "#  CAM lines are added by VDR\n" \
+                "#  Format [ (*) -> user configurable ]:\n" \
+                "#    (*)Flags,(*)Limit,<AppManufacturer:ManufacturerCode,CamTitle>\n" \
+                "#\n" \
+                "#  Flags (uint32) : OR'ed combination of:\n" \
+                "#                 CAMTWEAK_ENABLED    0x1 - enable/disable tweaks for this module\n" \
+                "#                 CAMTWEAK_FORCE_MCD  0x2 - force multi channel decryption (skip CA_PMT querying)\n" \
+                "#                 CAMTWEAK_AVOID_MTD  0x4 - not all CAMs will work with the MTD generated PIDs\n" \
+                "#                 CAMTWEAK_PACK_MCD   0x10 - pack each CamSlot into a single CA_PMT - for CAMs with limited program slots\n" \
+                "#                 CAMTWEAK_PACK_MTD   0x20 - pack *all* MtdCamSlots into a single CA_PMT - for CAMs with only one program slot\n" \
+                "#                 CAMTWEAK_STATIC_CAPMT 0x40 - create a static CAPMT for configured number of services and pids\n" \
+                "#\n" \
+                "#                 For testing only:\n" \
+                "#                 CAMTWEAK_DESELECT   0x800 - explicitly deselect Pids and ECMs at stream-level with CmdId 'NOT_SELECTED'\n" \
+                "#                 CAMTWEAK_DEBUG      0x1000 - print CamTweaks related debug messages\n" \
+                "#                 CAMTWEAK_DBGMTD     0x2000 - print MTD related debug messages\n" \
+                "#\n" \
+                "#  Limit (int)    : the number of programs the CAM can decrypt simultaneously\n" \
+                "#                 : (applies only if CAMTWEAK_FORCE_MCD is set):\n" \
+                "#                 0 -> no limit (for testing, up to VDR/CAM failure), 1 -> no MCD, 2...n -> a save CAM limit\n" \
+                "#\n" \
+                "#  Example:  0x3,2,<...> tweaks enabled, MCD forced, MTD allowed, CAM can decrypt 2 programs\n" \
+                "#  Example: 0x23,0,<...> tweaks enabled, PACK_MTD (single CA_PMT for MCD+MTD, unlimited number of programs)\n" \
+                "#  Example: 0x43,2,<...>,[0x69C:3:4] tweaks enabled, MTD, static CAPMT for CAID 0x69C, 3 services, max. 4 pids each\n" \
+                "#\n";
+  if (!*fileName)
+     return;
+  cMutexLock MutexLock(&mutex);
+  dsyslog("saving %s", *fileName);
+  cSafeFile f(fileName);
+  if (f.Open()) {
+     fprintf(f, "%s\n", help);
+     for (cCaModuleTweak *cmt = First(); cmt; cmt = Next(cmt)) {
+         bool withStaticOpts = (cmt->CamFlags() & CAMTWEAK_STATIC_CAPMT) || cmt->ScaConf();
+         const char *staticOpts = cmt->ScaConf() ? cmt->ScaConf() : "0x0:0:0";
+         cString s = cString::sprintf(withStaticOpts ? "0x%X,%d,<%04hX:%04hX,%s>,[%s]" : "0x%X,%d,<%04hX:%04hX,%s>",
+                                      cmt->CamFlags(), cmt->McdLimit(), cmt->CamManuf(), cmt->CamMcode(), cmt->CamName(), staticOpts);
+         if (*s)
+            fprintf(f, "%s\n", *s);
+         }
+     f.Close();
+     }
   else
      LOG_ERROR_STR(*fileName);
 }
diff -Nurp vdr-2.4.4.orig/ci.h vdr-2.4.4/ci.h
--- vdr-2.4.4.orig/ci.h	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/ci.h	2020-07-16 20:10:17.600037433 +0200
@@ -77,6 +77,8 @@ public:
   virtual ~cCiApplicationInformation();
   virtual void Process(int Length = 0, const uint8_t *Data = NULL);
   bool EnterMenu(void);
+  uint16_t GetApplicationManufacturer(void) { return applicationManufacturer; }
+  uint16_t GetManufacturerCode(void) { return manufacturerCode; }
   const char *GetMenuString(void) { return menuString; }
   };
 
@@ -221,12 +223,14 @@ class cMtdHandler;
 class cMtdMapper;
 class cMtdCamSlot;
 class cCiCaPmt;
+class cScaMapper;
 
 struct cCiCaPmtList {
   cVector<cCiCaPmt *> caPmts;
   ~cCiCaPmtList();
-  cCiCaPmt *Add(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds);
+  cCiCaPmt *Add(uint8_t CmdId, int Source, int Transponder, int ProgramNumber, const int *CaSystemIds, uint32_t CamTweaks = 0);
   void Del(cCiCaPmt *CaPmt);
+  cDynamicBuffer *CaPmt(int Index);
   };
 
 class cCamSlot : public cListObject {
@@ -251,7 +255,9 @@ private:
   bool resendPmt;
   int source;
   int transponder;
+public:
   cList<cCiCaProgramData> caProgramList;
+private:
   bool mtdAvailable;
   cMtdHandler *mtdHandler;
   void KeepSharedCaPids(int ProgramNumber, const int *CaSystemIds, int *CaPids);
@@ -262,17 +268,41 @@ private:
   cCiSession *GetSessionByResourceId(uint32_t ResourceId);
   void MtdActivate(bool On);
        ///< Activates (On == true) or deactivates (On == false) MTD.
+  uint32_t camTweakFlags;
+       /// CAM Tweaks : bitmap with flags
+  int camTweakMcdLimit;
+       /// CAM Tweaks : user defined limit for multichannel decryption
+  cVector<uint16_t> serviceSlots;
+  cVector<uint16_t> serviceSlotActives;
+  cVector<uint8_t>  serviceSlotCmdIds;
+public:
+  int activeProgsPrev;
+  int activeProgs;
+  int activePids;
+       /// CAM Tweaks : number of active programs/pids in the CAM Slot.
+  bool caplActive;
+       /// PACK_CAPMT: true if the CAM Slot's caProgramList has active programs.
+  bool caplModified;
+       /// PACK_CAPMT: true if the CAM Slot's caProgramList has modified programs.
+  cScaMapper *scaMapper;
 protected:
   virtual const int *GetCaSystemIds(void);
   virtual void SendCaPmt(uint8_t CmdId);
   virtual bool RepliesToQuery(void);
        ///< Returns true if the CAM in this slot replies to queries and thus
        ///< supports MCD ("Multi Channel Decryption").
+public:
+  bool McdForced(void);
+       ///< Returns true if the CAM in this slot is forced by setup to support MCD
+  int InitStaticCaPmt(cVector<uint32_t> &VscaConf);
+  bool SendStaticCaPmt(cVector<uint32_t> &VscaConf);
+       //// initialize scaMapper and send static CAPMT to CAM
   void BuildCaPmts(uint8_t CmdId, cCiCaPmtList &CaPmtList, cMtdMapper *MtdMapper = NULL);
        ///< Generates all CA_PMTs with the given CmdId and stores them in the given CaPmtList.
        ///< If MtdMapper is given, all SIDs and PIDs will be mapped accordingly.
   void SendCaPmts(cCiCaPmtList &CaPmtList);
        ///< Sends the given list of CA_PMTs to the CAM.
+protected:
   void MtdEnable(void);
        ///< Enables MTD support for this CAM. Note that actual MTD operation also
        ///< requires a CAM that supports MCD ("Multi Channel Decryption").
@@ -281,12 +311,28 @@ protected:
        ///< that are using this CAM. Data must point to the beginning of a TS packet.
        ///< Returns the number of bytes actually processed.
 public:
-  bool McdAvailable(void) { return RepliesToQuery(); }
+  bool McdAvailable(void) { return McdForced() || RepliesToQuery(); }
        ///< Returns true if this CAM supports MCD ("Multi Channel Decyption").
   bool MtdAvailable(void) { return mtdAvailable; }
        ///< Returns true if this CAM supports MTD ("Multi Transponder Decryption").
   bool MtdActive(void) { return mtdHandler != NULL; }
        ///< Returns true if MTD is currently active.
+  virtual int MtdNumber(void) { return 0; }
+       ///< Returns the MTD camslot index + 1' if this CAM supports MTD or '0' for the masterslot.
+  virtual int GetCaPmtSid(int Sid, int MtdNumber = 0);
+       ///< Returns a generated programNumber in case of PACK_CAPMT or the unmodified Sid.
+  void CaPmtTracker(cCiCaPmt *CaPmt);
+  void ResetCaPmtTracker(void);
+  int NumCamServices(void);
+  bool IsCamService(uint16_t Sid);
+  virtual uint32_t GetCamTweakFlags(void) { return camTweakFlags; }
+  void SetCamTweakFlags(uint32_t flags) { camTweakFlags = flags; }
+  void SetCamTweakMcdLimit(int limit) { camTweakMcdLimit = limit; }
+  uint32_t CaPmtPackStatic(void);
+  uint32_t CaPmtPack(void);
+       ///< PACK_CAPMT: Flags (PACK_MCD, PACK_MTD) to tell how all <mtd>CamSlots should be packed into a single caPmt
+  bool     CaPmtPackMtd(void);
+  bool     CaPmtStatic(void);
 public:
   cCamSlot(cCiAdapter *CiAdapter, bool WantsTsData = false, cCamSlot *MasterSlot = NULL);
        ///< Creates a new CAM slot for the given CiAdapter.
@@ -314,7 +360,7 @@ public:
        ///< a call to this function returns a cMtdCamSlot with this CAM slot
        ///< as its master. Otherwise a pointer to this object is returned, which
        ///< means that MTD is not supported.
-  void TriggerResendPmt(void) { resendPmt = true; }
+  void TriggerResendPmt(bool ResendPmt = true) { resendPmt = ResendPmt; }
        ///< Tells this CAM slot to resend the list of CA_PMTs to the CAM.
   virtual bool Assign(cDevice *Device, bool Query = false);
        ///< Assigns this CAM slot to the given Device, if this is possible.
@@ -388,6 +434,10 @@ public:
   int Priority(void);
        ///< Returns the priority of the device this slot is currently assigned
        ///< to, or IDLEPRIORITY if it is not assigned to any device.
+  bool CaProgramListActive(void);
+       /// Returns true if the CAMs caProgramList has active programs
+  bool CaProgramListModified(void);
+       /// Returns true if the CAMs caProgramList has modified programs
   virtual bool ProvidesCa(const int *CaSystemIds);
        ///< Returns true if the CAM in this slot provides one of the given
        ///< CaSystemIds. This doesn't necessarily mean that it will be
@@ -432,6 +482,8 @@ public:
        ///< StopDecrypting().
   virtual bool IsDecrypting(void);
        ///< Returns true if the CAM in this slot is currently used for decrypting.
+  uchar *ScaMapDecrypt(uchar *Data, int &Count);
+       //// CamTweaks: decrypt with static pid mapping
   virtual uchar *Decrypt(uchar *Data, int &Count);
        ///< If this is a CAM slot that can be freely assigned to any device,
        ///< but will not be directly inserted into the full TS data stream
@@ -532,4 +584,48 @@ extern cChannelCamRelations ChannelCamRe
 
 bool CamResponsesLoad(const char *FileName, bool AllowComments = false, bool MustExist = false);
 
+// --- cCaModuleTweaks ---------------------------------------------------
+
+class cCaModuleTweak : public cListObject {
+private:
+  uint16_t camManuf;
+  uint16_t camMcode;
+  char     *camName;
+  uint32_t camFlags;
+  int      mcdLimit;
+  char     *scaConf;
+  cVector<uint32_t> vScaConf;
+public:
+  cCaModuleTweak(uint16_t Manuf, uint16_t Mcode, const char *Mname);
+  ~cCaModuleTweak();
+  uint16_t CamManuf(void) { return camManuf; }
+  uint16_t CamMcode(void) { return camMcode; }
+  char     *CamName(void) { return camName; }
+  uint32_t CamFlags(void) { return camFlags; }
+  int      McdLimit(void) { return mcdLimit; }
+  char     *ScaConf(void) { return scaConf; }
+  cVector<uint32_t> &VscaConf(void) { return vScaConf; }
+
+  bool     Match(uint16_t Manuf, uint16_t Mcode, const char *Mname)
+                { return ((camManuf == Manuf) && (camMcode == Mcode) && !strcmp(camName,Mname)); }
+  void     Set(uint32_t Flags, int Limit, char *ScaConf);
+  void     SetSca(void);
+  };
+
+// --- cCaModuleTweaks ---------------------------------------------------
+
+class cCaModuleTweaks : public cList<cCaModuleTweak> {
+private:
+  cMutex mutex;
+  cString fileName;
+public:
+  cCaModuleTweaks(void) {};
+  cCaModuleTweak *GetEntry(uint16_t Manuf, uint16_t Mcode, const char *Cname);
+  cCaModuleTweak *AddEntry(uint16_t Manuf, uint16_t Mcode, const char *Cname, uint32_t Flags, int Limit, char *ScaConf);
+  void Load(const char *FileName);
+  void Save(void);
+  };
+
+extern cCaModuleTweaks CaModuleTweaks;
+
 #endif //__CI_H
diff -Nurp vdr-2.4.4.orig/config.c vdr-2.4.4/config.c
--- vdr-2.4.4.orig/config.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/config.c	2020-07-16 20:10:17.600037433 +0200
@@ -497,6 +497,7 @@ cSetup::cSetup(void)
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+  EnableCamTweaks = 0;
 }
 
 cSetup& cSetup::operator= (const cSetup &s)
@@ -726,6 +727,7 @@ bool cSetup::Parse(const char *Name, con
   else if (!strcasecmp(Name, "ShowChannelNamesWithSource")) ShowChannelNamesWithSource = atoi(Value);
   else if (!strcasecmp(Name, "EmergencyExit"))       EmergencyExit      = atoi(Value);
   else if (!strcasecmp(Name, "LastReplayed"))        cReplayControl::SetRecording(Value);
+  else if (!strcasecmp(Name, "EnableCamTweaks"))     EnableCamTweaks = atoi(Value);
   else
      return false;
   return true;
@@ -858,6 +860,7 @@ bool cSetup::Save(void)
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
   Store("LastReplayed",       cReplayControl::LastReplayed());
+  Store("EnableCamTweaks",    EnableCamTweaks);
 
   Sort();
 
diff -Nurp vdr-2.4.4.orig/config.h vdr-2.4.4/config.h
--- vdr-2.4.4.orig/config.h	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/config.h	2020-07-16 20:10:17.600037433 +0200
@@ -359,6 +359,7 @@ public:
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+  int EnableCamTweaks;
   int __EndData__;
   cString InitialChannel;
   cString DeviceBondings;
diff -Nurp vdr-2.4.4.orig/device.c vdr-2.4.4/device.c
--- vdr-2.4.4.orig/device.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/device.c	2020-07-16 20:10:17.603370766 +0200
@@ -287,9 +287,12 @@ cDevice *cDevice::GetDevice(const cChann
           bool ndr;
           if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basically able to do the job
              if (NumUsableSlots && !HasInternalCam) {
-                if (cCamSlot *csi = device[i]->CamSlot()) {
-                   cCamSlot *csj = CamSlots.Get(j);
-                   if ((csj->MtdActive() ? csi->MasterSlot() : csi) != csj)
+                cCamSlot *csi = device[i]->CamSlot();
+                cCamSlot *csj = CamSlots.Get(j);
+                if (!csi || csi->MasterSlot() != csj) {
+                   if (csj->McdForced() && !csj->CanDecrypt(Channel))
+                      continue; // CAM slot would be over the limits if adding this channel/service
+                   if (csi)
                       ndr = true; // using a different CAM slot requires detaching receivers
                    }
                 }
@@ -446,6 +449,8 @@ void cDevice::SetCamSlot(cCamSlot *CamSl
 {
   LOCK_THREAD;
   camSlot = CamSlot;
+  scaMapper = CamSlot ? CamSlot->scaMapper : NULL;
+  scaMapMasterSlot = scaMapper && CamSlot->IsMasterSlot() && !CamSlot->MtdActive();
 }
 
 void cDevice::Shutdown(void)
@@ -1730,7 +1735,7 @@ void cDevice::Action(void)
                            time_t Now = time(NULL);
                            if (cCamSlot *cs = CamSlot()) {
                               if (Now != Receiver->lastEitInjection) { // once per second
-                                 cs->InjectEit(Receiver->ChannelID().Sid());
+                                 cs->InjectEit(cs->GetCaPmtSid(Receiver->ChannelID().Sid()));
                                  Receiver->lastEitInjection = Now;
                                  }
                               }
diff -Nurp vdr-2.4.4.orig/device.h vdr-2.4.4/device.h
--- vdr-2.4.4.orig/device.h	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/device.h	2020-07-16 20:10:17.603370766 +0200
@@ -86,6 +86,7 @@ struct tTrackId {
 class cPlayer;
 class cReceiver;
 class cLiveSubtitle;
+class cScaMapper;
 
 class cDeviceHook : public cListObject {
 public:
@@ -465,6 +466,10 @@ public:
 
 private:
   cCamSlot *camSlot;
+  cScaMapper *scaMapper;
+      /// Set if CamSlots static CAPMT mapping is active
+  bool scaMapMasterSlot;
+      /// True if static CAPMT mapping and MCD (but not MTD) is active
 public:
   virtual bool HasCi(void);
          ///< Returns true if this device has a Common Interface.
@@ -479,6 +484,8 @@ public:
   cCamSlot *CamSlot(void) const { return camSlot; }
          ///< Returns the CAM slot that is currently used with this device,
          ///< or NULL if no CAM slot is in use.
+  cScaMapper *ScaMapper(void) const { return scaMapper; }
+  bool ScaMapMasterSlot(void) const { return scaMapMasterSlot; }
 
 // Image Grab facilities
 
diff -Nurp vdr-2.4.4.orig/dvbdevice.c vdr-2.4.4/dvbdevice.c
--- vdr-2.4.4.orig/dvbdevice.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/dvbdevice.c	2020-07-16 20:10:17.603370766 +0200
@@ -20,6 +20,7 @@
 #include "dvbci.h"
 #include "menuitems.h"
 #include "sourceparams.h"
+#include "scapmt.h"
 
 static int DvbApiVersion = 0x0000; // the version of the DVB driver actually in use (will be determined by the first device created)
 
@@ -2334,7 +2335,10 @@ bool cDvbDevice::GetTSPacket(uchar *&Dat
            Data = tsBuffer->Get(&Available, checkTsBuffer);
            if (!Data)
               Available = 0;
-           Data = cs->Decrypt(Data, Available);
+           if (ScaMapMasterSlot())
+              Data = cs->ScaMapDecrypt(Data, Available);
+           else
+              Data = cs->Decrypt(Data, Available);
            tsBuffer->Skip(Available);
            checkTsBuffer = Data != NULL;
            return true;
diff -Nurp vdr-2.4.4.orig/menu.c vdr-2.4.4/menu.c
--- vdr-2.4.4.orig/menu.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/menu.c	2020-07-16 20:10:17.606704099 +0200
@@ -4197,6 +4197,7 @@ void cMenuSetupMisc::Set(void)
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Channels wrap"),              &data.ChannelsWrap));
   Add(new cMenuEditStraItem(tr("Setup.Miscellaneous$Show channel names with source"), &data.ShowChannelNamesWithSource, 3, showChannelNamesWithSourceTexts));
   Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Emergency exit"),             &data.EmergencyExit));
+  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Enable CA module tweaks"),    &data.EnableCamTweaks));
   SetCurrent(Get(current));
   Display();
 }
diff -Nurp vdr-2.4.4.orig/mtd.c vdr-2.4.4/mtd.c
--- vdr-2.4.4.orig/mtd.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/mtd.c	2020-07-16 20:10:17.606704099 +0200
@@ -9,13 +9,13 @@
 
 #include "mtd.h"
 #include "receiver.h"
+#include "scapmt.h"
 
-//#define DEBUG_MTD
-#ifdef DEBUG_MTD
-#define DBGMTD(a...) dsyslog(a)
-#else
-#define DBGMTD(a...)
-#endif
+extern bool DebugCamtweaks; // set by camtweaks.conf
+extern bool DebugCamtweaksMtd; // set by camtweaks.conf
+
+#define DBGMTDMAP(a...) if (DebugCamtweaks) dsyslog(a)
+#define DBGMTD(a...) if (DebugCamtweaksMtd) dsyslog(a)
 
 //#define KEEPPIDS // for testing and debugging - USE ONLY IF YOU KNOW WHAT YOU ARE DOING!
 
@@ -26,13 +26,14 @@
 #else
 #define MAX_UNIQ_PIDS  256    // uniq PIDs are 8 bit (0x00 - 0xFF)
 #define UNIQ_PID_MASK  0x00FF
-#define UNIQ_PID_SHIFT 8
 #endif // KEEPPIDS
+#define UNIQ_PID_SHIFT 8
 
 // --- cMtdHandler -----------------------------------------------------------
 
 cMtdHandler::cMtdHandler(void)
 {
+  scaMapper = NULL;
 }
 
 cMtdHandler::~cMtdHandler()
@@ -53,17 +54,22 @@ cMtdCamSlot *cMtdHandler::GetMtdCamSlot(
       }
   dsyslog("CAM %d/%d: creating new MTD CAM slot", MasterSlot->SlotNumber(), camSlots.Size() + 1);
   cMtdCamSlot *s = new cMtdCamSlot(MasterSlot, camSlots.Size());
+  s->scaMapper = scaMapper;
   camSlots.Append(s);
   return s;
 }
 
-int cMtdHandler::Put(const uchar *Data, int Count)
+int cMtdHandler::Put(uchar *Data, int Count)
 {
   int Used = 0;
   while (Count >= TS_SIZE) {
         if (int Skipped = TS_SYNC(Data, Count))
            return Used + Skipped;
         int Pid = TsPid(Data);
+        if (scaMapper && SCAMAPPED(Pid)) {
+           Pid = scaMapper->UniqToRealPid(Pid);
+           TsSetPid(Data, Pid);
+           }
 #ifdef KEEPPIDS
         int Index = 0;
 #else
@@ -93,6 +99,64 @@ int cMtdHandler::Priority(void)
   return p;
 }
 
+bool cMtdHandler::CaProgramListActive(void)
+{
+  for (int i = 0; i < camSlots.Size(); i++) {
+      if (camSlots[i]->CaProgramListActive())
+         return true;
+      }
+  return false;
+}
+
+bool cMtdHandler::CaProgramListModified(void)
+{
+  for (int i = 0; i < camSlots.Size(); i++) {
+      if (camSlots[i]->CaProgramListModified())
+         return true;
+      }
+  return false;
+}
+
+int cMtdHandler::CamActiveProgsPrev(void)
+{ 
+  int actives = 0;
+  for (int i = 0; i < camSlots.Size(); i++)
+      actives += camSlots[i]->activeProgsPrev;
+  return actives;
+}
+
+int cMtdHandler::CamActiveProgs(void)
+{ 
+  int actives = 0;
+  for (int i = 0; i < camSlots.Size(); i++)
+      actives += camSlots[i]->activeProgs;
+  return actives;
+}
+
+int cMtdHandler::CamActivePids(void)
+{ 
+  int actives = 0;
+  for (int i = 0; i < camSlots.Size(); i++)
+      actives += camSlots[i]->activePids;
+  return actives;
+}
+
+void cMtdHandler::SendCaPmt(uint8_t CmdId, cCamSlot *MasterSlot, bool ResendPmt)
+{
+  cCiCaPmtList CaPmtList;
+  for (int i = 0; i < camSlots.Size(); i++) {
+      if (camSlots[i]->Device()) {
+         camSlots[i]->caplActive = MasterSlot->caplActive;
+         camSlots[i]->caplModified = MasterSlot->caplModified;
+
+         camSlots[i]->TriggerResendPmt(ResendPmt);
+         camSlots[i]->BuildCaPmts(CmdId, CaPmtList, camSlots[i]->MtdMapper());
+         camSlots[i]->TriggerResendPmt(false);
+         }
+      }
+  MasterSlot->SendCaPmts(CaPmtList);
+}
+
 bool cMtdHandler::IsDecrypting(void)
 {
   for (int i = 0; i < camSlots.Size(); i++) {
@@ -108,6 +172,7 @@ void cMtdHandler::StartDecrypting(void)
       if (camSlots[i]->Device()) {
          camSlots[i]->TriggerResendPmt();
          camSlots[i]->StartDecrypting();
+         camSlots[i]->TriggerResendPmt(false);
          }
       }
 }
@@ -157,6 +222,7 @@ private:
   int number;
   int masterCamSlotNumber;
   int nextUniqPid;
+  int numInvalidPids;
   uint16_t uniqPids[MAX_REAL_PIDS]; // maps a real PID to a unique PID
   uint16_t realPids[MAX_UNIQ_PIDS]; // maps a unique PID to a real PID
   cVector<uint16_t> uniqSids;
@@ -168,6 +234,8 @@ public:
   uint16_t UniqToRealPid(uint16_t UniqPid) { return realPids[UniqPid & UNIQ_PID_MASK]; }
   uint16_t RealToUniqSid(uint16_t RealSid);
   void Clear(void);
+  int Number(void) { return number; }
+  void CntInvalidPid(uint16_t Pid) { numInvalidPids++; }
   };
 
 cMtdMapper::cMtdMapper(int Number, int MasterCamSlotNumber)
@@ -175,6 +243,7 @@ cMtdMapper::cMtdMapper(int Number, int M
   number = Number;
   masterCamSlotNumber = MasterCamSlotNumber;
   nextUniqPid = 0;
+  numInvalidPids = 0;
   Clear();
 }
 
@@ -223,6 +292,10 @@ uint16_t cMtdMapper::RealToUniqSid(uint1
 
 void cMtdMapper::Clear(void)
 {
+  if (numInvalidPids) {
+     DBGMTDMAP("//////// MTD mapper status: skipped %d not remapable (old) TS packets", numInvalidPids);
+     numInvalidPids = 0;
+     }
   DBGMTD("CAM %d/%d: MTD mapper cleared", masterCamSlotNumber, number);
   memset(uniqPids, 0, sizeof(uniqPids));
   memset(realPids, MTD_INVALID_PID, sizeof(realPids));
@@ -236,11 +309,20 @@ void MtdMapSid(uchar *p, cMtdMapper *Mtd
   uint16_t UniqSid = MtdMapper->RealToUniqSid(RealSid);
   p[0] = UniqSid >> 8;
   p[1] = UniqSid & 0xff;
+  DBGMTDMAP("------ %s: %u (%04X) -> %u (%04X)", __func__, RealSid, RealSid, UniqSid, UniqSid);
 }
 
 void MtdMapPid(uchar *p, cMtdMapper *MtdMapper)
 {
-  Poke13(p, MtdMapper->RealToUniqPid(Peek13(p)));
+  uint16_t RealPid = Peek13(p);
+  uint16_t UniqPid = MtdMapper->RealToUniqPid(RealPid);
+  Poke13(p, UniqPid);
+  DBGMTDMAP("------ %s: %d (%04X) -> %d (%04X)", __func__, RealPid, RealPid, UniqPid, UniqPid);
+}
+
+int MtdMapperNumber(cMtdMapper *MtdMapper)
+{
+  return MtdMapper->Number();
 }
 
 // --- cMtdCamSlot -----------------------------------------------------------
@@ -270,12 +352,24 @@ const int *cMtdCamSlot::GetCaSystemIds(v
 
 void cMtdCamSlot::SendCaPmt(uint8_t CmdId)
 {
+  if (CaPmtPackMtd()) {
+     MasterSlot()->SendCaPmt(CmdId);
+     return;
+     }
   cMutexLock MutexLock(&mutex);
+  caplActive = CaProgramListActive();
+  caplModified = CaProgramListModified();
+
   cCiCaPmtList CaPmtList;
   BuildCaPmts(CmdId, CaPmtList, mtdMapper);
   MasterSlot()->SendCaPmts(CaPmtList);
 }
 
+uint32_t cMtdCamSlot::GetCamTweakFlags(void)
+{
+  return MasterSlot()->GetCamTweakFlags();
+}
+
 bool cMtdCamSlot::RepliesToQuery(void)
 {
   return MasterSlot()->RepliesToQuery();
@@ -293,6 +387,7 @@ bool cMtdCamSlot::CanDecrypt(const cChan
 
 void cMtdCamSlot::StartDecrypting(void)
 {
+  // !! this is ddci2 specific code !!
   MasterSlot()->StartDecrypting();
   cCamSlot::StartDecrypting();
 }
@@ -313,6 +408,10 @@ uchar *cMtdCamSlot::Decrypt(uchar *Data,
      Count = TS_SIZE;
      int Pid = TsPid(Data);
      TsSetPid(Data, mtdMapper->RealToUniqPid(Pid));
+
+     if (scaMapper)
+        Data = scaMapper->TsPreProcess(Data, Count); // unwanted Pid: Data == NULL, Count == TS_SIZE
+
      MasterSlot()->Decrypt(Data, Count);
      if (Count == 0)
         TsSetPid(Data, Pid); // must restore PID for later retry
@@ -334,7 +433,14 @@ uchar *cMtdCamSlot::Decrypt(uchar *Data,
         return NULL;
         }
      if (c >= TS_SIZE) {
-        TsSetPid(d, mtdMapper->UniqToRealPid(TsPid(d)));
+        uint16_t UniqPid = TsPid(d);
+        uint16_t RealPid = mtdMapper->UniqToRealPid(UniqPid);
+        if (RealPid != MTD_INVALID_PID)
+           TsSetPid(d, RealPid);
+        else {
+           d = NULL; // skip
+           mtdMapper->CntInvalidPid(UniqPid);
+           }
         delivered = true;
         }
      else
@@ -350,7 +456,9 @@ bool cMtdCamSlot::TsPostProcess(uchar *D
 
 void cMtdCamSlot::InjectEit(int Sid)
 {
-  MasterSlot()->InjectEit(mtdMapper->RealToUniqSid(Sid));
+  uint16_t UniqSid = CaPmtPackStatic() ? Sid : mtdMapper->RealToUniqSid(Sid); // PACK_CAPMT: no Sid mapping required
+  DBGMTDMAP("------ %s: %d (%04X) -> %d (%04X)", __func__, Sid, Sid, UniqSid, UniqSid);
+  MasterSlot()->InjectEit(UniqSid);
 }
 
 int cMtdCamSlot::PutData(const uchar *Data, int Count)
@@ -369,3 +477,13 @@ int cMtdCamSlot::PutCat(const uchar *Dat
   MasterSlot()->Decrypt(const_cast<uchar *>(Data), Count);
   return Count;
 }
+
+int cMtdCamSlot::MtdNumber(void)
+{
+  return mtdMapper->Number();
+}
+
+int cMtdCamSlot::GetCaPmtSid(int Sid, int MtdNumber)
+{
+  return MasterSlot()->GetCaPmtSid(Sid, mtdMapper->Number());
+}
diff -Nurp vdr-2.4.4.orig/mtd.h vdr-2.4.4/mtd.h
--- vdr-2.4.4.orig/mtd.h	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/mtd.h	2020-07-16 20:10:17.606704099 +0200
@@ -108,9 +108,12 @@ mapped in cCiCaPmt::MtdMapPids().
 #include "remux.h"
 #include "ringbuffer.h"
 
+class cScaMapper;
+
 class cMtdHandler {
 private:
   cVector<cMtdCamSlot *> camSlots;
+  cScaMapper *scaMapper;
 public:
   cMtdHandler(void);
       ///< Creates a new MTD handler that distributes TS data received through
@@ -121,13 +124,23 @@ public:
   cMtdCamSlot *GetMtdCamSlot(cCamSlot *MasterSlot);
       ///< Creates a new MTD CAM slot, or reuses an existing one that is currently
       ///< unused.
-  int Put(const uchar *Data, int Count);
+  int Put(uchar *Data, int Count);
       ///< Puts at most Count bytes of Data into the CAM slot which's index is
       ///< derived from the PID of the TS packets.
       ///< Data must point to the beginning of a TS packet.
       ///< Returns the number of bytes actually stored.
   int Priority(void);
       ///< Returns the maximum priority of any of the active MTD CAM slots.
+  bool CaProgramListActive(void);
+       /// Returns true if any of the MTD CAM slots caProgramList has active programs.
+  bool CaProgramListModified(void);
+       /// Returns true if any of the MTD CAM slots caProgramList has modified programs.
+  int CamActiveProgsPrev(void);
+  int CamActiveProgs(void);
+  int CamActivePids(void);
+      ///< Returns the number of active programs/pids of all MTD CAM slots.
+  void SendCaPmt(uint8_t CmdId, cCamSlot *MasterSlot, bool ResendPmt);
+       ///< Pack all MTD CAM slots and send the list of CA_PMTs to the CAM.
   bool IsDecrypting(void);
       ///< Returns true if any of the active MTD CAM slots is currently decrypting.
   void StartDecrypting(void);
@@ -144,15 +157,17 @@ public:
       ///< Returns true if the array is not empty.
   void UnAssignAll(void);
       ///< Unassigns all MTD CAM slots from their devices.
+  void SetScaMapper(cScaMapper *ScaMapper) { scaMapper = ScaMapper; }
   };
 
 #define MTD_DONT_CALL(v) dsyslog("PROGRAMMING ERROR (%s,%d): DON'T CALL %s", __FILE__, __LINE__, __FUNCTION__); return v;
 
 class cMtdMapper;
-
 void MtdMapSid(uchar *p, cMtdMapper *MtdMapper);
 void MtdMapPid(uchar *p, cMtdMapper *MtdMapper);
 
+int MtdMapperNumber(cMtdMapper *MtdMapper);
+
 class cMtdCamSlot : public cCamSlot {
 private:
   cMutex clearMutex;
@@ -162,6 +177,7 @@ private:
 protected:
   virtual const int *GetCaSystemIds(void);
   virtual void SendCaPmt(uint8_t CmdId);
+  virtual uint32_t GetCamTweakFlags(void);
 public:
   cMtdCamSlot(cCamSlot *MasterSlot, int Index);
        ///< Creates a new "Multi Transponder Decryption" CAM slot, connected to the
@@ -178,6 +194,8 @@ public:
   virtual void InjectEit(int Sid);
   int PutData(const uchar *Data, int Count);
   int PutCat(const uchar *Data, int Count);
+  virtual int MtdNumber(void);
+  virtual int GetCaPmtSid(int Sid, int MtdNumber = 0);
   // The following functions shall not be called for a cMtdCamSlot:
   virtual cCamSlot *Spawn(void) { MTD_DONT_CALL(NULL); }
   virtual bool Reset(void) { MTD_DONT_CALL(false); }
diff -Nurp vdr-2.4.4.orig/scapmt.c vdr-2.4.4/scapmt.c
--- vdr-2.4.4.orig/scapmt.c	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.4.4/scapmt.c	2020-07-16 20:10:17.606704099 +0200
@@ -0,0 +1,422 @@
+/*
+ * scapmt.c: Static CaPmt pid mapping
+ */
+
+#include "libsi/si.h"
+#include "ci.h"
+#include "scapmt.h"
+
+ // set by camtweaks.conf
+extern bool DebugCamtweaks;
+extern bool DebugCamtweaksMtd;
+
+#define DBGSTATICMAP(a...) if (DebugCamtweaks) dsyslog(a)
+#define DBGSTATIC(a...) if (DebugCamtweaksMtd) dsyslog(a)
+
+#define SCASLOT(u)       ((u >> SCA_SLOT_SHIFT) & SCA_SLOT_MASK)
+#define IS_SCA_ECMPID(p) ((p & (SCA_CAPID_BIT | SCA_INDEX_MASK)) == SCA_CAPID_BIT)
+#define IS_SCA_CAPID(u)  (u & SCA_CAPID_BIT)
+#define IS_SCA_PID(u)    (u & SCA_PID_BIT)
+
+// --- cScaMapper ------------------------------------------------------------
+
+enum { oCAID    = 0,
+       oNumPids = 1,
+       oTrigger = 2,
+       oSID     = 3,
+       oECM     = 4,
+       oPIDS    = 5
+       };
+
+cScaMapper::cScaMapper(cVector<uint32_t> &VscaConf, cCamSlot *MasterSlot)
+{
+  maxSids = 0;
+  maxPids = 0;
+  masterSlot = MasterSlot;
+  caPmtSent = false;
+
+  Clear();
+  // initialize the service slots with CAID and number of pids
+  for (int n = 0; n < VscaConf.Size(); n++) {
+      uint32_t sca = VscaConf[n];
+      vScaConf.Append(sca); // copy
+      int caId = (sca >> 16) & 0xFFFF;
+      int sids = (sca >>  8) & 0xFF;
+      int pids = (sca      ) & 0xFF;
+      dsyslog("CAM %d: activating static CaPmt mapping: CAID 0x%04X, %d services, %d pids", MasterSlot->SlotNumber(), caId, sids, pids);
+      maxPids = max(maxPids, pids); // ?
+      for (int s = 0; s < sids && maxSids < SCA_MAX_SERVICES; s++) {
+          uint16_t *sCam = camServices[maxSids++];
+          sCam[oCAID]    = caId;
+          sCam[oNumPids] = pids;
+          }
+      }
+}
+
+cScaMapper::~cScaMapper()
+{
+}
+
+void cScaMapper::Clear(void)
+{
+  memset(uniqPids, 0, sizeof(uniqPids));
+  memset(realPids, SCA_INVALID_PID, sizeof(realPids));
+  memset(uniqUsed, 0, sizeof(uniqUsed));
+  nextUniqPid = 0;
+
+  memset(camServices, 0, sizeof(camServices));
+  memset(pmtServices, 0, sizeof(pmtServices));
+  numPmtServices = 0;
+
+  ecmAction = false;
+  ecmShared = false;
+}
+
+uint16_t cScaMapper::UniqCaPid(int ServiceSlot, int Index)
+{
+  return SCA_CAPID(ServiceSlot,Index);
+}
+
+// map CAPMT Pids
+uint16_t cScaMapper::MapUniqCaPid(uint16_t RealPid, int ServiceSlot, int Index)
+{
+  uint16_t uniq = SCA_CAPID(ServiceSlot,Index); // 0x1000...0x10FF
+  uint16_t uniqCurr = uniqPids[RealPid];
+
+  bool shared = false;
+  if (IS_SCA_CAPID(uniqCurr)) {
+     int slot = SCASLOT(uniqCurr);
+     if (slot != ServiceSlot && camServices[slot][oSID]) { // uses by another active slot
+        DBGSTATICMAP(">>> StatCapmt: shared CAPID %d(%04X) slot[%d] -> [%d]", RealPid, RealPid, slot, ServiceSlot);
+        shared = true;
+        }
+     }
+  if (!shared)
+     uniqPids[RealPid] = uniq;
+  realPids[uniq] = RealPid;
+  DBGSTATICMAP(">>> StatCapmt: slot[%d] map CAPID %d(%04X) to %d(%04X)", ServiceSlot, RealPid, RealPid, uniq, uniq);
+  return uniq;
+}
+
+// map common Pids
+uint16_t cScaMapper::MapUniqPid(uint16_t RealPid)
+{
+  for (int i = 0, n = nextUniqPid; i < SCA_MAX_UNIQ_PIDS; i++, n++) {
+      n %= SCA_MAX_UNIQ_PIDS;
+      if (!uniqUsed[n]) { // inactive
+         int uniq = SCA_PID(n); // 0x800...0xFFF
+
+         int realCurr = realPids[uniq];
+         if (realCurr != SCA_INVALID_PID && IS_SCA_PID(uniqPids[realCurr])) // old real <-> uniq connection
+            uniqPids[realCurr] = 0; // unlink
+
+         realPids[uniq] = RealPid;
+         uniqPids[RealPid] = uniq;
+         DBGSTATICMAP(">>> StatCapmt: mapped PID %d(%04X) to %d(%04X)", RealPid, RealPid, uniq, uniq);
+
+         uniqUsed[n] = true; // mark active
+         nextUniqPid = n + 1;
+         return uniq;
+         }
+      }
+  esyslog(">>> StatCapmt: ERROR - mapper ran out of unique PIDs");
+  return 0;
+}
+
+// free unused common uniq Pid mapping
+void cScaMapper::SetPid(int RealPid, bool On)
+{
+  DBGSTATICMAP("...cs:setpid %c %d(%X)", On ? '+' : '-', RealPid, RealPid);
+  if (!On) { // disable
+     int uniq = uniqPids[RealPid];
+     if (IS_SCA_PID(uniq))
+        uniqUsed[uniq & SCA_UNIQ_PID_MASK] = On;
+     }
+}
+
+// --- static CAPMT mapping and shared ECM handling
+
+#define RESET_ECM 1
+
+uchar *cScaMapper::TsPreProcess(uchar *Data, int &Count)
+{
+  cMutexLock MutexLock(&mutex);
+  int pid = TsPid(Data);
+  int uniq = RealToUniqPid(pid);
+
+  if (uniq == TSNULL) // unwanted Pid -> skip
+     return NULL;
+
+  TsSetPid(Data, uniq); // STATIC CAPMT pid mapping
+  ////
+  //// handle shared Ecm and clearing of the CAMs ecm bufferr
+  ////
+  if (ecmAction && IS_SCA_ECMPID(uniq)) {
+     ecmAction = ecmShared;
+     int slot = SCASLOT(uniq);
+     for (int i = 0; i < maxSids; i++) {
+         uint16_t *sCam = camServices[i];
+         if (sCam[oSID] && sCam[oECM] == pid) { // active slot for this ECM Pid
+            if (i != slot) { // slot uses a shared ECM
+               //DBGSTATICMAP(">>> StatCapmt: Inject shared ECM pid 0x%X as 0x%X for slot[%d]", uniq, SCA_CAPID(i, 0), i);
+               TsSetPid(Data, SCA_CAPID(i, 0));
+#if RESET_ECM
+               if (sCam[oTrigger]) // new service
+                  sCam[oTrigger] = !EcmTrigger(Data);
+#endif
+               masterSlot->Inject(Data, TS_SIZE); // duplicate
+               TsSetPid(Data, uniq); // restore pid
+               }
+#if RESET_ECM
+            else if (sCam[oTrigger]) // new service
+               sCam[oTrigger] = !EcmTrigger(Data);
+            if (sCam[oTrigger])
+               ecmAction = true; // need ecmTrigger
+#endif
+            }
+         }
+     }
+  ////
+  return Data;
+}
+
+bool cScaMapper::EcmTrigger(uchar *TsPacket)
+{
+  // inject with toggled ECM Table-Id to clear CAMs ECM buffer ?
+  if (TsPacket[4] == 0) { // simple: expect payload at offset 0
+     uint8_t tableId = TsPacket[5];
+     if ((tableId & 0xFE) == 0x80) { // ECM odd/even data
+        TsPacket[5] = tableId == 0x80 ? 0x81 : 0x80;
+        DBGSTATICMAP(">>> StatCapmt: Trigger ECM data with TableId 0x%02X/0x%02X", TsPacket[5], tableId);
+        // 3 times the 'other'
+        masterSlot->Inject(TsPacket, TS_SIZE);
+        masterSlot->Inject(TsPacket, TS_SIZE);
+        masterSlot->Inject(TsPacket, TS_SIZE);
+        // 2 + 1 times 'current'
+        TsPacket[5] = tableId;
+        masterSlot->Inject(TsPacket, TS_SIZE);
+        masterSlot->Inject(TsPacket, TS_SIZE);
+        return true;
+        }
+     }
+  return false;
+}
+
+bool cScaMapper::HasSharedEcm(uint16_t CaId)
+{
+  for (int i = 0; i < maxSids; i++) {
+      uint16_t *sCam1 = camServices[i];
+      if (sCam1[oCAID] == CaId && sCam1[oSID]) { // active slot
+         for (int j = i + 1; j < maxSids; j++) {
+             uint16_t *sCam2 = camServices[j];
+             if (sCam2[oCAID] == CaId && sCam2[oSID] && sCam2[oECM] == sCam1[oECM]) // shared Ecm
+                return true;
+             }
+         }
+      }
+  return false;
+}
+
+void cScaMapper::RemapSharedEcm(uint16_t CaId, uint16_t Ecm)
+{
+  int slot = -1;
+  int uniq = RealToUniqPid(Ecm); // current mapping
+
+  for (int i = 0; i < maxSids; i++) {
+      uint16_t *sCam = camServices[i];
+      if (sCam[oCAID] == CaId && sCam[oSID] && sCam[oECM] == Ecm) { // ECM used by this active slot
+         if (SCA_CAPID(i, 0) == uniq)  // match
+            return;
+         slot = i; // shared ECM, remap to this active slot if required
+         }
+      }
+  if (slot >= 0)
+     MapUniqCaPid(Ecm, slot, 0); // remap shared ECM
+}
+
+// ---
+
+int cScaMapper::GetServiceSlot(uint16_t CaId, uint16_t Sid)
+{
+  int slot = -1;
+  for (int i = 0; i < maxSids; i++) {
+      uint16_t *sCam = camServices[i];
+      if (sCam[oCAID] == CaId) {
+         if (sCam[oSID] == Sid)
+            return i; // active service found
+         if (slot < 0 && !sCam[oSID])
+            slot = i; // select first inactive slot
+         }
+      }
+  return slot;
+}
+
+void cScaMapper::AddService(int ServiceSlot, uint16_t *sPmt)
+{
+  int i, j;
+  uint16_t *sCam = camServices[ServiceSlot];
+
+  if (!caPmtSent) {
+     caPmtSent = masterSlot->SendStaticCaPmt(vScaConf);
+     if (!caPmtSent) {
+        esyslog(">>> StatCapmt: failed to send static CAPMT to CAM");
+        return;
+        }
+     }
+
+  DBGSTATICMAP(">>> StatCapmt: Link service %d(%X) to slot[%d]", sPmt[oSID], sPmt[oSID], ServiceSlot);
+
+  ecmAction = sCam[oECM]; // ecm -> slot was in use before, do an ECM "trigger"
+  sCam[oTrigger] = ecmAction;
+
+  sCam[oSID] = sPmt[oSID]; // sid
+  for (i = oECM, j = 0; sPmt[i]; i++, j++) { // ecm, pid1, pid2, ..
+      int realPid = sPmt[i];
+      if (j <= sCam[oNumPids]) {
+         MapUniqCaPid(realPid, ServiceSlot, j);
+         sCam[i] = realPid;
+         }
+      else { // too many pids - map to TSNULL and skip after Decrypt()
+         dsyslog(">>> StatCapmt: Sid %d(%X): Pid %d(%X) over limit!", sPmt[oSID], sPmt[oSID], realPid, realPid);
+         uniqPids[realPid] = TSNULL; // will not be sent to the CAM
+         }
+      }
+  sCam[i] = 0; // zero termination
+}
+
+void cScaMapper::DelService(int ServiceSlot)
+{
+  uint16_t *sCam = camServices[ServiceSlot];
+  DBGSTATICMAP(">>> StatCapmt: Unlink service %d(%X) from slot[%d]", sCam[oSID], sCam[oSID], ServiceSlot);
+
+  sCam[oSID] = 0; // sid 0 to indicate inactive service slot
+  RemapSharedEcm(sCam[oCAID], sCam[oECM]);
+  }
+
+void cScaMapper::MapStaticCaPmts(cCiCaPmtList &CaPmtList)
+{
+  if (!ParseCaPmts(CaPmtList))
+     return;
+
+  for (int j = 0; j < numPmtServices; j++) {
+      uint16_t *sPmt = pmtServices[j];
+      uint16_t sid = sPmt[oSID];
+      uint16_t caId = sPmt[oCAID];
+      int serviceSlot = caId ? GetServiceSlot(caId, sid) : -1;
+
+      if (sPmt[oTrigger]) { // add / update
+         if (serviceSlot >= 0)
+            AddService(serviceSlot, sPmt); // activate or update this slot
+         else
+            dsyslog(">>> StatCapmt: *** ERROR *** No free slot for service %d(%X)", sid, sid);
+         }
+      else { // remove
+         if (serviceSlot >= 0 && camServices[serviceSlot][oSID]) // active slot
+            DelService(serviceSlot);
+         }
+      if (HasSharedEcm(caId))
+         ecmShared = true;
+      }
+  ecmAction = ecmAction || ecmShared;
+}
+
+bool cScaMapper::ParseCaPmts(cCiCaPmtList &CaPmtList)
+{
+  cVector<uint16_t> ecmPids;
+  cVector<uint16_t> esPids;
+  cVector<uint16_t> caIds;
+
+  if (!CaPmtList.caPmts.Size())
+     return false; // no CAPMT changes
+
+  numPmtServices = 0;
+  for (int i = 0; i < CaPmtList.caPmts.Size() && numPmtServices < SCA_MAX_SERVICES; i++) {
+      cDynamicBuffer *capmt = CaPmtList.CaPmt(i);
+      uint16_t sid = capmt->Get(1) << 8 | capmt->Get(2);
+
+      if (!sid)
+         continue;
+
+      esPids.Clear();
+      ecmPids.Clear();
+      caIds.Clear();
+      ParseCaPmt(capmt, esPids, ecmPids, caIds); // changed services
+
+      if (esPids.Size() && (ecmPids.Size() != 1 || caIds.Size() != 1))
+         dsyslog(">>> StatCapmt: *** WARNING *** Sid %d(%X) EsPids/EcmPids/CaIds: %d/%d/%d", sid, sid, esPids.Size(), ecmPids.Size(), caIds.Size());
+
+      uint16_t *sPmt = pmtServices[numPmtServices];
+      sPmt[oCAID] = caIds.Size() ? caIds[0] : 0;
+      sPmt[oTrigger] = (esPids.Size() && caIds.Size()) ? 1 : 0;  // Trigger 0 indicate a removed or FTA service
+      sPmt[oSID] = sid;
+      sPmt[oECM] = ecmPids.Size() ? ecmPids[0] : 0;
+      int n = oPIDS;
+      for (int j = 0; j < SCA_MAX_ESPIDS && j < esPids.Size(); j++)
+          sPmt[n++] = esPids[j];
+      sPmt[n] = 0; // zero termination
+
+      numPmtServices++;
+      DBGSTATICMAP(">>> StatCapmt: Sid %d(%X) EsPids/EcmPids/CaIds: %d/%d/%d", sid, sid, n - oPIDS, ecmPids.Size(), caIds.Size());
+      }
+   return true;
+}
+
+// --- PARSE CAPMT
+
+#define CPCI_OK_DESCRAMBLING  0x01 // ci.c
+
+uint8_t ParseCaDescriptors(uchar *p, int Length, cVector<uint16_t> &ecmPids, cVector<uint16_t> &caIds)
+{
+  uint8_t cmdid = 0; 
+  if (Length >= 1) {
+     cmdid = *p++;
+     Length--;
+     for (int l = 0; Length > 1 && *p == SI::CaDescriptorTag; Length -= l, p += l) {
+         l = p[1] + 2;
+         if (l >= 6) {
+            uint16_t caid = p[2] << 8 | p[3];
+            uint16_t ecm = Peek13(p + 4);
+            DBGSTATICMAP(">>> StatCapmt: capmt   [%d] ca %X e %d(%X)", cmdid, caid, ecm, ecm);
+            caIds.AppendUnique(caid);
+            ecmPids.AppendUnique(ecm);
+            }
+         else
+            break;
+         }
+     }
+  return cmdid;
+}
+
+void ParseStreams(uchar *p, int Length, cVector<uint16_t> &esPids, cVector<uint16_t> &ecmPids, cVector<uint16_t> &caIds, uint8_t plCmdid)
+{
+  for (int l = 0; Length >= 5; Length -= l, p += l) {
+      uint16_t pid = Peek13(p + 1);
+      l = p[3] * 256 + p[4];
+      uint8_t esCmdid = ParseCaDescriptors(p + 5, l, ecmPids, caIds);
+      l += 5;
+      bool Ok = esCmdid ? esCmdid == CPCI_OK_DESCRAMBLING : plCmdid == CPCI_OK_DESCRAMBLING;
+      DBGSTATICMAP(">>> StatCapmt: capmt    p %c%d(%X)", Ok ? '+' : '-', pid, pid);
+      if (Ok)
+         esPids.AppendUnique(pid);
+      }
+}
+
+void cScaMapper::ParseCaPmt(cDynamicBuffer *capmt, cVector<uint16_t> &esPids, cVector<uint16_t> &ecmPids, cVector<uint16_t> &caIds)
+{
+  uchar *p = capmt->Data();
+  int Length = capmt->Length();
+
+  if (Length >= 3) {
+     uint8_t lm = capmt->Get(0);
+     uint16_t sid = capmt->Get(1) << 8 | capmt->Get(2);
+     DBGSTATICMAP(">>> StatCapmt: capmt <%d> %d(%X)", lm, sid, sid);
+     if (Length >= 6) {
+        int l = p[4] * 256 + p[5];
+        uint8_t plCmdid = ParseCaDescriptors(p + 6, l, ecmPids, caIds);
+        l += 6;
+        ParseStreams(p + l, Length - l, esPids, ecmPids, caIds, plCmdid);
+        }
+     }
+}
+
+// ---
diff -Nurp vdr-2.4.4.orig/scapmt.h vdr-2.4.4/scapmt.h
--- vdr-2.4.4.orig/scapmt.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-2.4.4/scapmt.h	2020-07-16 20:10:17.606704099 +0200
@@ -0,0 +1,87 @@
+/*
+ * scapmt.h: Static CaPmt pid mapping
+ */
+
+#ifndef __SCA_H
+#define __SCA_H
+
+///
+
+#include "remux.h"
+
+#define SCA_MAX_PIDS     MAXPID // real PIDs are 13 bit (0x0000 - 0x1FFF)
+#define SCA_INVALID_PID  0xFFFF // see MTD_INVALID_ID in mtd.c
+
+#define SCA_MAX_SERVICES 16
+#define SCA_MAX_CAPIDS   16
+#define SCA_MAX_ESPIDS  (SCA_MAX_CAPIDS - 1) // -1 for ECM-Pid
+
+#define SCA_SLOT_SHIFT   4
+#define SCA_SLOT_MASK    0xF
+#define SCA_INDEX_MASK   0xF
+
+#define SCA_CAPID_BIT 0x1000 // 1 << 12
+#define SCA_PID_BIT   0x800  // 1 << 11
+
+#define SCA_PID(p)            (SCA_PID_BIT   | (p))
+#define SCA_CAPID(slot,index) (SCA_CAPID_BIT | ((slot) << SCA_SLOT_SHIFT) | (index))
+
+#define SCA_MAX_UNIQ_PIDS 0x800   // common uniq PIDs are 11 bit (0x0000 - 0x07FF)
+#define SCA_UNIQ_PID_MASK 0x7FF
+
+#define TSNULL 0x1FFF
+#define SCAMAPPED(p)    ((p) >= SCA_PID_BIT && (p) != TSNULL)
+
+class cCamSLot;
+class cCiCaPmtList;
+
+class cScaMapper {
+private:
+  cMutex mutex;
+  uint16_t uniqPids[SCA_MAX_PIDS]; // maps a real PID to a unique PID
+  uint16_t realPids[SCA_MAX_PIDS]; // maps a unique PID to a real PID
+  bool uniqUsed[SCA_MAX_UNIQ_PIDS]; // availability of unique PIDs
+  int nextUniqPid;
+
+  uint16_t camServices[SCA_MAX_SERVICES][ 5 + SCA_MAX_ESPIDS + 1]; // caid + NumPids + flags + sid + ecm + pids.. zero terminated
+  uint16_t pmtServices[SCA_MAX_SERVICES][ 5 + SCA_MAX_ESPIDS + 1];
+  int numPmtServices;
+
+  int maxSids;
+  int maxPids;
+  cCamSlot *masterSlot;
+  cVector<uint32_t> vScaConf;
+  bool caPmtSent;
+
+  bool ecmAction;
+  bool ecmShared;
+
+  void Clear(void);
+  uint16_t MapUniqCaPid(uint16_t RealPid, int Service, int Index);
+  uint16_t MapUniqPid(uint16_t RealPid);
+
+  bool EcmTrigger(uchar *TsPacket);
+  bool HasSharedEcm(uint16_t CaId);
+  void RemapSharedEcm(uint16_t CaId, uint16_t Ecm);
+
+  int GetServiceSlot(uint16_t CaId, uint16_t Sid);
+  void AddService(int ServiceSlot, uint16_t *sPmt);
+  void DelService(int ServiceSlot);
+
+  bool ParseCaPmts(cCiCaPmtList &CaPmtList);
+  void ParseCaPmt(cDynamicBuffer *capmt, cVector<uint16_t> &esPids, cVector<uint16_t> &ecmPids, cVector<uint16_t> &caIds);
+
+public:
+  cScaMapper(cVector<uint32_t> &VscaConf, cCamSlot *MasterSlot);
+  ~cScaMapper();
+  uint16_t RealToUniqPid(uint16_t RealPid) { return uniqPids[RealPid] ? uniqPids[RealPid] : MapUniqPid(RealPid); }
+  uint16_t UniqToRealPid(uint16_t UniqPid) { return realPids[UniqPid]; }
+  uint16_t UniqCaPid(int ServiceSlot, int Index);
+  uchar *TsPreProcess(uchar *Data, int &Count);
+  void MapStaticCaPmts(cCiCaPmtList &CaPmtList);
+  void SetPid(int RealPid, bool On);
+  int NumSids(void) { return maxSids; }
+  int NumPids(void) { return maxPids; }
+  };
+
+#endif //__SCA_H
diff -Nurp vdr-2.4.4.orig/vdr.c vdr-2.4.4/vdr.c
--- vdr-2.4.4.orig/vdr.c	2020-07-13 08:16:41.000000000 +0200
+++ vdr-2.4.4/vdr.c	2020-07-16 20:10:17.606704099 +0200
@@ -783,6 +783,7 @@ int main(int argc, char *argv[])
   KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true);
   Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
   CamResponsesLoad(AddDirectory(ConfigDirectory, "camresponses.conf"), true);
+  CaModuleTweaks.Load(AddDirectory(ConfigDirectory, "camtweaks.conf"));
 
   if (!*cFont::GetFontFileName(Setup.FontOsd)) {
      const char *msg = "no fonts available - OSD will not show any text!";
@@ -1600,6 +1601,7 @@ Exit:
   signal(SIGALRM, SIG_DFL);
 
   StopSVDRPHandler();
+  CaModuleTweaks.Save();
   ChannelCamRelations.Save();
   cRecordControls::Shutdown();
   PluginManager.StopPlugins();
